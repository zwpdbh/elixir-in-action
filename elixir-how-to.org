* How to define functions 
  - Functions with same name but different arity is different function.
* How to define private function 
  - def is public, defp is private
  
* How to organize code 
  - A module is a collection of functions, like namespace. Functions must be defined inside a module.
  - A file can contain multiple module.
  - Rules
    - Module name starts with uppercase letter and is usually formated as CamelCase style.
    - Use ~.~ in module to represent herachichy. We could also define child module inside module.
    - Function name are like abc_def. 

* How to call functions from other module 
  - We could import other module into current module, to allow us to call functions without module prefix.
  - We could use change the module's name 
    #+begin_src text
      alias IO, as: MyIO
    #+end_src
  - For example, let閳ユ獨 say you have a Geometry.Rectangle module. You can alias it in your client module and use a shorter name
    #+begin_src elixir
      defmodule MyModule do 
        alias Geometry.Rectangle, as: Rectange 
        
        def my_fun do
          Rectange.area(...)
        end
      end
    #+end_src
    
* How define constants in modules
  - Module attributes.
    - ~@~ constant exists only during the compilation of the module.
    
* How to compile the code 
  - In Emacs, ~M-x alchemist-iex-send-last-sexp~.
  - In terminal, ~iex geometry.ex~.
  
  The code will be compiled and resulting module is loaded into the runtime.
  
* How to do type specification
  #+begin_src elixir
    defmodule Circle do
      @pi 3.14
      
      @spec area(number) :: number 
      def area(r) do
        r * r * @pi
      end
    end
  #+end_src
  
* How to get the integer from div
  - The division operator ~/~ always return float.
  - To get integer use 
    - ~div~ to get the integer part.
    - ~rem~ to get the remainder
  
* How to define constant 
  - *Atom*, like ~:this_is_an_atom~

* How to use Tuples
  #+begin_src elixir
    person = {"bob", 25}
    
    age = elem(persion, 1) # => 25
    put_elem(person, 1, 100) # => {"bob", 100}
  #+end_src
  - Untyped structure, or record, group a *fixed* number of element together.
* How to use List 
  #+begin_src elixir
    iex(11)>prime_numbers = [2, 3, 5, 7]
    [2, 3, 5, 7]
    iex(12)> length(prime_numbers)
    length(prime_numbers)
    4
    iex(13)> Enum.at(prime_numbers, 1)
    Enum.at(prime_numbers, 1)
    3
    iex(14)> 100 in prime_numbers
    100 in prime_numbers
    false
    iex(15)> List.replace_at(prime_numbers, 0 , 11)
    List.replace_at(prime_numbers, 0 , 11)
    [11, 3, 5, 7]
    iex(16)> prime_numbers
    prime_numbers
    [2, 3, 5, 7]
    iex(17)> new_primes = List.replace_at(prime_numbers, 0 , 11)
    new_primes = List.replace_at(prime_numbers, 0 , 11)
    [11, 3, 5, 7]
    iex(18)> new_primes = List.insert_at(new_primes, 3, 13)
    new_primes = List.insert_at(new_primes, 3, 13)
    [11, 3, 5, 13, 7]
    iex(19)> new_primes
    new_primes
    [11, 3, 5, 13, 7]
    iex(20)> new_primes = List.insert_at(new_primes, -1, 103)
    new_primes = List.insert_at(new_primes, -1, 103)
    [11, 3, 5, 13, 7, 103]
    iex(21)> [1, 2, 3] ++ [4, 5]
    [1, 2, 3] ++ [4, 5]
    [1, 2, 3, 4, 5]
    iex(22)> hd([1, 2, 3, 4])
    hd([1, 2, 3, 4])
    1
    
    iex(23)> tl([1, 2, 3, 4])
    tl([1, 2, 3, 4])
    [2, 3, 4]
    
    iex(24)> a_list = [5, :value, true]
    a_list = [5, :value, true]
    [5, :value, true]
    iex(25)> new_list = [:new_element | a_list]
    new_list = [:new_element | a_list]
    [:new_element, 5, :value, true]
  #+end_src
  
* How to use Map 
  - As key/value store 
    #+begin_src elixir
      # Dynamically sized map 
      empty_map = %{}
      
      # map with value
      squares = %{1 => 1, 2 => 4, 3 => 9}
      # or 
      squares = Map.new([{1, 1}, {2, 4}, {3, 9}])
      
      # fetch value for a given key 
      squares[2] # where 1 is the key, => 4
      squares[7] # => nil
      # or 
      Map.get(squares, 2) # => 4
      Map.get(squares, 8, :not_found) #=> :not_found, use this to specify default value.
      Map.fetch(squares, 5) #=> :error  This will distinguishly produce  
      # or raise exception 
      Map.fetch!(squares, 5)
    #+end_src
  - power dynamically sized key/value structures, overlap Tuples' feature but let you to access fields by name
    #+begin_src elixir
      bob = %{:name => "Bob", :age => 25, :works_at => "Initech"}
      # if keys are atom, we could short as 
      bob = %{name: "Bob", age: 25, works_at: "Initech"}
       
      
      # fetch 
      bob[:works_at] # => Initech
      bod[:non_exist_key] #=> nil 
      # or use short syntax if key is atom 
      bob.age #=> 25
      # though it will get KeyError if the key is not exist
      
      
      next_bob = %{bob | age: 26}
      # => %{age: 26, name: "Bob", works_at: "Initech"}
      next_bob = %{bob | age: 26, works_at: "no_where"} # change multiple key/value
    #+end_src
    - Can only update keys exist in map!
    - *Use map to hold structured* data is very common.
      
* Why use struct instead of map
- ~struct~ can catch key not match error at compile time. 
* How to process binaries 
  - A binary is a chunk of byte
  - Create binary by enclosing the byte sequence
    #+begin_src elixir
      <<1, 2, 3>>
    #+end_src
    - Each number represent the value of the corresponding byte.
    - If the value is bigger than 255, it is truncated to the byte size
      #+begin_src elixir
        <<257>> #=> <<1>>
      #+end_src
  - Specify the size of each value and tell the compiler how many bits to use for that particular value 
    #+begin_src elixir
      <<234::16>> # => <<0, 234>>, used 2 bytes, the first has value 0, the second is 234 
      <<1234::32>> # => <<0, 0, 4, 210>>
    #+end_src
  - The size specifier is in *bits* and not needed to be a multiple of 8!!
    #+begin_src elixir
      <<1::4, 15::4>> # => <<31>>
    #+end_src
  - If the total size of all values is not a multiple of 8, it is called a bitstring -- a sequence of bits 
    #+begin_src elixir
      <<1::1, 0::1, 1::1>> # => <<5::size(3)>>
    #+end_src
  - Concatenate two binaries with ~<>~
    #+begin_src elixir
      <<1, 2>> <> <<3, 4>> # => <<1, 2, 3, 4>>
    #+end_src

* How to represent string 
  - String in elixir is either a binary or a list type.
  - String inter -- evaluate values in string template
    #+begin_src elixir
      "embedded expression: #{1 + 3}" #=>"embedded expression: 4"
    #+end_src
  - How to include quote inside string
    #+begin_src elixir
      ~s("embedded expression": #{1 + 3}) #=> "\"embedded expression\": 4"
      
      """ 
      embedded expression: "#{1 + 3}" 
      """
      # => "embedded expression: \"4\"\n"
    #+end_src
  - Aother way to represent string is use single-quote 
    #+begin_src elixir
      'ABC'
      [65, 66, 67] 
      # => they both produce 'ABC'
    #+end_src
    - The runtime doesn't distinguish between a list of integers and a character list.

* How to convert between binary string to character list 
  - binary string is represent using ~""~ while character list is represent as ~''~.
  - Use binary string as much as possbile
  - Convert 
    #+begin_src elixir
      String.to_charlist("ABC")       
    #+end_src

* How to define Lambda function and use it 
- basic lambda 
  #+begin_src elixir
    square = fn x ->
      x * x
    end

    iex(2)> square.(24)
    square.(24)
    576
  #+end_src
  - The dot operator is to make the code explicit such that you know an anonymous function is being called.
  - ~square(5)~ will be a named function defined somewhere in the module.
- *Capture* makes us to make full function qualifier as lambda 
  #+begin_src elixir
    Enum.each([1, 2, 3, 4], &IO.puts/1)

    iex(4)> Enum.each([1, 2, 3, 4], &IO.puts/1)
    1
    2
    3
    4
    :ok
  #+end_src
  
- The closure capture *doesn't* affect the previous defined lambda that references the same symbolic name
  #+begin_src elixir
    outside_var = 5
    lambda = fn -> IO.puts(outside_var) end
    outside_var = 6
    lambda.() #=> 5
  #+end_src
  
* How to use other types 
1) range
2) keyword list 
   - A list of pair, where the first one is atom.
   - Often used for small key-value structures.
   - Often used as the last optional argument when define a function.
3) MapSet, a set implementation
4) Time and date
   #+begin_src elixir
     date = ~D[2008-09-30]
     time = ~T[11:59:12]
     naive_datetime = ~N[2018-01-31 11:59:12.000007]
   #+end_src
5) *IO lists*
   - Special for incrementally building output that will be forwarded to an I/O service.
   - Appending to an IO list is O(1), very useful to incrementally build a stream of bytes 
     #+begin_src elixir
       iolist = []
       iolist = [iolist, "This"]
       iolist = [iolist, "is"]
       iolist = [iolist, "Amazing"]

       iex(20)> iolist = []
       iex(21)> [[], "This"]
       iex(22)> [[[], "This"], "is"]
       iex(23)> [[[[], "This"], "is"], "Amazing"]
       iex(24)> IO.puts(iolist)
       IO.puts(iolist)
       ThisisAmazing
       :ok
     #+end_src

* How to use lib from mix 
1) In mix.exs, add the lib into ~deps~.
2) In iex, run ~recompile()~ or disconnect from iex and re-run alchemist-iex-project-run: "C-c a i p".
3) Test the example of lib in iex shell.
4) If we want to shortcut the name, we could use ~alias~ to create short name.
* How to check the and load additional code paths 
- load additional code path from command-line when started erlang runtime 
  #+begin_src elixir
    $ iex -pa my/code/path -pa another/code/path # from command-line to load additional code path 
  #+end_src
- once start runtime, check current loaded path 
  #+begin_src elixir
    :code.get_path # check path 
  #+end_src  
  
* How to dynamically call a function  
#+begin_src elixir
  apply(IO, :puts, ["Dynamic function call."])
#+end_src

* How to run a single script
- Create ~.exs~ file 
  #+begin_src elixir :file script.exs
    defmodule MyModule do
      def run  do
        IO.puts("Called Mymodule.run")
      end
    end

    # Code outside of a module is executed immediately
    MyModule.run
  #+end_src

- On terminal 
  #+begin_src sh
    elixir script.exs
  #+end_src
  - With ~--no-halt~, it will make the BEAM instance keep running. Useful when your script start other concurrent tasks.

* How to get current time 
#+begin_src elixir
  iex(28)> {_, time} = :calendar.local_time()
  {{2022, 2, 11}, {13, 32, 10}}
  iex(29)> time 
  time 
  {13, 32, 10}
#+end_src

* How to handle exception error in guard
- If an error is raised from inside the guard, it won't be propagated. And the guard expression will return false. The corresponding clause won't match.

* How to match the content of variable
#+begin_src elixir
  iex(30)> expected_name = "bob"
  expected_name = "bob"
  "bob"
  iex(31)> {^expected_name, age} = {"bob", 25}
  {^expected_name, age} = {"bob", 25}
  {"bob", 25}
  iex(32)> age 
  age 
  25
#+end_src


* How to check the type of a variable
  - From REPL 
    #+begin_src elixir
      iex(10)> i x
      i x
      Term
        1
      Data type
        Integer
      Reference modules
        Integer
      Implemented protocols
        IEx.Info, Inspect, List.Chars, String.Chars
    #+end_src
  - From code 
    #+begin_src elixir
      defmodule Util do
          def typeof(a) do
              cond do
                  is_float(a)    -> "float"
                  is_number(a)   -> "number"
                  is_atom(a)     -> "atom"
                  is_boolean(a)  -> "boolean"
                  is_binary(a)   -> "binary"
                  is_function(a) -> "function"
                  is_list(a)     -> "list"
                  is_tuple(a)    -> "tuple"
                  true           -> "idunno"
              end    
          end
      end
      
      cases = [
          1.337, 
          1337, 
          :'1337', 
          true, 
          <<1, 3, 3, 7>>, 
          (fn(x) -> x end), 
          {1, 3, 3, 7}
      ]
      
      Enum.each cases, fn(case) -> 
          IO.puts (inspect case) <> " is a " <> (Util.typeof case)
      end
    #+end_src

* How to chain multiple pattern matching
  #+begin_src elixir
    defmodule ChainPattern do
      # define some helper function
      def extract_login(%{"login" => login}) do
        {:ok, login}
      end
      def extract_login(_) do
        {:error, "login missed"}
      end
    
      def extract_email(%{"email" => email}) do
        {:ok, email}
      end
      def extract_email(_) do
        {:error, "email missed"}
      end
    
      def extract_password(%{"password" => password}) do
        {:ok, password}
      end
      def extract_password(_) do
        {:error, "password missed"}
      end
    
    
      def extract_info(submitted) do
        with {:ok, login} <-extract_login(submitted),
          {:ok, email} <-extract_email(submitted),
          {:ok, password} <-extract_password(submitted) do
          {:ok, %{login: login, email: email, password: password}}
        end
      end
    end
    
    submitted = %{
      "login" => "alice",
      "email" => "some_email",
      "password" => "password",
      "other_field" => "some_value",
      "yet_another_not_wanted_field" => "..."
    }
    
    # iex(20)> ChainPattern.extract_info(submitted)
    # ChainPattern.extract_info(submitted)
    # {:ok, %{email: "some_email", login: "alice", password: "password"}}
  #+end_src
* How to build abstraction 
  - Princple
    - Module is used as the abstraction over the data type.
    - Modifier functions should return data of the same type. 
    - Query functions expect an instance of the data abstraction as the first argument and return another type of information.
* How to update hierachical data 
  - In general
    - We can't directly modify part of it that resides deep in its tree.
    - We have to walk down the tree to particular part that needs to be modified, and then transform it and all of its ancestors.
    - The result is a copy of the entire model.
  - Useful macros from Kernel:
    - ~put_in/2~
    - ~put_in/3~
    - ~get_in/2~
    - ~update_in/2~
    - ~get_and_update_in/2~
  - Those macros rely on the *Access* module. So, if we want our custom data to work with Access, we need to implement a couple of function required by *Access* contract. See: [[https://hexdocs.pm/elixir/Access.html][Access behaviour]]

* How to achieve polymorphism using protocols
  - What is a protocol 
    It is a module in which you declare functions without implementing them.
  - The protocol implementation doesn't need to be part of any module. It means: you can implement a protocol for a type even if you can't modify the type's source code.

* How to register a process
  - If you know there will always be only one instance of some type of server, you can give the process a local name and use that name to send messages to the process. The name is called local because it has meaning only in the currently running BEAM instance.
  - Using the registered server is much simpler becaue we don't need to pass server pid around through interface.
  - Example
    #+begin_src elixir
      Process.register(self(), :some_name)
      
      send(:some_name, :msg)
      receive do
        msg -> IO.puts("received #{msg}")
      end
    #+end_src
* How to handle unlimited process mailbox problem
  - If a message is not match, it will be stored in mailbox with unlimited number. If we don't process them, they will slow down the system and even crash the system when all memory is consumed.
  - For each server process, we should introduce a *match-all* receive clause that deals with unexpected kind of messages.

* How to implement a general server process
  - In general, there are 5 things to do 
    - spawn a seperate process
    - loop to infinite in that process  
    - receive message
    - send message back to the caller
    - maintain state


* How to debug
  - Check the representation of a struct 
    #+begin_src elixir
      Fraction.new(1,4)
      |> IO.inspect() 
      |> Fraction.add(Fraction.new(1,4))
      |> IO.inspect()
      |> Fraction.value()
      
      # %Fraction{a: 1, b: 4}
      # iex(70)> %Fraction{a: 1, b: 4}
      # %Fraction{a: 1, b: 4}
      # iex(71)> %Fraction{a: 8, b: 16}
      # iex(72)> %Fraction{a: 8, b: 16}
      # %Fraction{a: 8, b: 16}
      # iex(73)> 0.5
    #+end_src

* How to get the number of currently running process 
#+begin_src elixir
  :erlang.system_info(:process_count)
#+end_src
* How state is maintained in server process 
- In plain server process implementation
  - State is passed as argument in loop clause. State is modified (new state) as the result of callback module's message handling.
  - This means the callback module's ~handle_call/2~ and ~handle_cast/2~ need to pass state as argument
- In GenServer 
  - state is passed in from callback module's interface as argument
  - state is passed in in ~handle_cast/2~ as argument

* How to create a singleton of a module
- Implement ~GenServer~ in your module 
  #+begin_src elixir
    def start do
      # locally register the process, make sure only one instance of the database process.
      GenServer.start(__MODULE__, nil, name: __MODULE__)
    end
  #+end_src
* Some notes 
  - Always keep in mind that a Boolean is just an atom that has a value of true or false.
  - short-circuit operators: ~||~, ~&&~, ~!~.
    - ~||~ returns the first expression that isn't falsy.
      - Use for like 
        #+begin_src elixir
          read_cache || read_from_disk || read_from_database
        #+end_src
    

* How to do OAuth
- ref: [[https://github.com/danschultzer/pow][Pow is a robust, modular, and extendable authentication and user management solution for Phoenix and Plug-based apps.]]
* Elixir in action study note 
- Chapter05 
  - Introduces the concept of a server process. 
  - A server process is a beam process that use recurive call (loop) to handle different messages.
    
- Chapter06
  - Introduce the generic server process
    - Instead of directly handle different message in that server process, we provide the server process with a callback module.
    - The callback module receive and handle's the specific message
      1) callback module call ~ServerProcess.start~ to register itself
      2) callback module handle messages by call ~ServerProcess.call~ or ~ServerProcess.cast~ (those messages are sent into server process)
      3) ~ServerProcess.call/cast~ goes into server process's loop:
         - The message is processed in callback module's ~:handle_call~ or ~:handle_cast~. 
         - Go back to server process loop, either update state to new state or send value in message to server process itself.
         - In ~ServerProcess.call~ or ~ServerProcess.cast~, message will be received. This goes back to 2).
    - The generic server process does
      1) use endless recursive call to loop
      2) in loop, *maintain state*
      3) provide 2 type of interface functions to let callback module handle messages: one for sync, another for async.
    - The pattern is very similar to other patterns: delication, master-worker, actor.
  - Use ~GenServer~ instead of using our own implemented generic server process.
    - ~init/1~
    - ~handle_cast/2~
    - ~handle_call/3~
  - What is the context of state in GenServer
    - During loop in server process, it needs to maintain state. So the state needed to be carried in loop as argument.
    - This also means, the callback module called inside the loop need to accept that state as argument.
    - So, in GenServer, the state is carried through argument.
      
- Chapter07       
  - We learned principles:
    - Make server process do things in sequential way.
    - Spawn multiple server processes to handle concurrency.
    - In general, 
      - if we need to do synchronization between multiple processes, we let one dedicate process to handle these.
      - make concurrent process run independently.

        
* Elixir with Phoenix notes 
** 02-24 
- create a project and start 
  #+begin_src sh
    mix phx.new hello
    cd hello/
    cd assets/
    npm install
    cd ..
    mix ecto.create # create db configuration
    mix phx.server
    # or 
    iex -S mix phx.server
  #+end_src
  - visit http://localhost:4000
- A new feature: print a string when you load a specific URL 
  All actions is done in ~lib/hello_web~
  1) Map requests coming in to a specific URL
     - Edit router, specify the controller, and a action name.
  2) tie a URL to a function on a controller
     - Define a function in controller
     - The name of the function should match the action name specified on router
  3) Tie that function to a view
     - But how how bind controller with view?
       - We defined a module ~HelloWeb.HelloView~
       - That file doesn閳ユ獩 actually do any work beyond tying the view for world with some code to render a template. We閳ユ獟l rely on the defaults to render a template.
     - Inside the action function from controller, we specify the render with a template
  4) About request parameters
     - Defined in router
     - Extract out in controller with patter matching
       - Notice the convention from string to atom
     - Use it template(<action_name>.html.eex) with "@<parameter_name>".
- About pattern matching, string and atom 
  #+begin_src elixir
    # from top to bottom, be shorthanded
    [{:name, name}]
    [:name => name]
    [name: name]
    name: name # if it is used as the last argument of a function
  #+end_src
- Problems about starts project as ~iex -S mix phx.server~ from Emacs 
  - Make sure the Emacs is running as Administrator.
  - If it has postgres issue, go to the project root, and re-run ~mix ecto.create~.
  - When start Phoenix project from Emacs using alchemist, the default command is ~iex -S mix~, we need to edit to ~iex -S mix phx.server~
    
- How to check Phoenix version 
  cd into mix project root folder, run 
  #+begin_src sh
    mix phx.new --version
  #+end_src
    
  
** 02-27
   - A view in Phoenix is just a module, and templates are just functions.
   - How to persistent out model data with database?
     1) Modify models from lib: for example, ~lib/rumbl/accounts/user.ex~.
        - This is for schema definition.
     2) run ~ecto.gen.migration~
        #+begin_src sh
          mix ecto.gen.migration create_users
        #+end_src
        - This will create migration ~<timesteamp>_create_users.exs~ file in path ~priv/migrations/~. 
        - Edit the generated ~.exs~ file to define. This is for use code to operator database to create corresponding tables.
        - In general, we write elixir code to create/update table schema.
     3) run ~mix ecto.migrate~
        - In this step, the actual table is created. 

          
     In general, 3 steps 
     - In lib modify our model 
       - Define schema using ~Ecto.Schema~
       - Define corresponding changeset.
     - Generate migration file, in which we define database operations.
     - Execute migration, by ~mix ecto.migrate~.
       
** 02-28
- After 
- Use ~mix phx.routes~ to check all available routes in our web application.
  
  


** 03-01
- After migration (create user table, we could test it from iex shell)
  #+begin_src elixir
    alias Rumbl.Repo
    alias Rumbl.Accounts.User

    Repo.insert(%User{name: "Jose", username: "josevalim"})
    Repo.insert(%User{name: "Bruce", username: "redrapids"})
    Repo.insert(%User{name: "Chris", username: "mccord"})
  #+end_src
  
- Check ~Phoenix.HTML.FormData~ contract to understand how the changes in the changeset available to the form.
  
- How to refer to specific routes in the application
  - Use ~YourApplication.Router.Helpers~. In fact, phx help use with ~alias RumblWeb.Router.Helpers, as: Routes~.
  - So, we can get any route through ~Routes.some_path~.

- Install application as dependencies
  - edit ~mix.exs~
    
  - ~mix deps.get~

- Check point01 
  1) Install password feature dependencies
  2) In ~user.ex~
     - define schema for password and password_hash
     - create our ~registration_changeset~
  3) Test in iex shell 
     #+begin_src elixir
       alias Rumbl.Accounts.User
       alias Rumbl.RumblWeb.Router.Helpers, as: Routes

       # this one is not valid 
       changeset = User.registration_changeset(%User{}, %{username: "max", name: "Max", password: "123"})

       # this one is valid 
       changeset = User.registration_changeset(%User{}, %{username: "max", name: "Max", password: "asecret"})
     #+end_src
     
- Check point02 
  - To fix already existing user to make them have valid password
    #+begin_src elixir
      recompile()
      alias Rumbl.Repo

      for u <- Repo.all(User) do 
          Repo.update!(User.registration_changeset(u, %{password: "gghh3344"}))
      end
    #+end_src
    - 

- Check point03 
  1) At this point, all users shall meet the requirement: new user registration need to have passworld.
  2) In Account module, use User module's registration changeset. (model)
  3) In user_controller, use exposed function from Account module.
  4) Modify new user html to provide slot for pasword. (view)

- Check point04 
  Check if there is a new user in the session and store it in ~conn.assigns~ for every incoming request. In other words, we need to prevent user to access certain action when there is no session record.
  - loading data from session
  - use it to restric user access
    
- Check point05 
  Add a mechanism to log the users in.
  - create login function in auth.ex
    - assigns current user
    - put session and configuration_session to reuse.    
  - use login function in user controller

    
- Problem01
  #+begin_src text
    lib/rumbl/accounts.ex:48: Users.__struct__/1 is undefined, cannot expand struct Users. Make sure the struct name is correct. If the struct name exists and is correct but it still cannot be found, you likely have cyclic module usage in your code
  #+end_src
  - When I add a new user, it shows this.
  - Following error message, I could solve this: there is a typo in accounts.ex which I use ~%Users{}~ instead of should use ~%User{}~.
    
** 03-02 
- Check Point 01 
  - Expose a function to validate username and password.
  - Use RESTful session API for 
    - GET for new session login form
    - POST for login
    - DELETE for logout
      
      
- Check Point 02 
  - Change the layout of the application to handle the new user features
    
- Problem01
  - When I go home to execute steps from check point02. I got error:
    #+begin_src text
      iex(3)> for u <- Repo.all(User) do 
          Repo.update!(User.registration_changeset(u, %{password: "tmppass"}))
      end
      ...(3)> ...(3)> ** (Protocol.UndefinedError) protocol Ecto.Queryable not implemented for User of type Atom, the given module does not exist. This protocol is implemented for the following type(s): Atom, BitString, Ecto.Query, Ecto.SubQuery, Tuple
          (ecto 3.7.1) lib/ecto/queryable.ex:40: Ecto.Queryable.Atom.to_query/1
          (ecto 3.7.1) lib/ecto/repo/queryable.ex:16: Ecto.Repo.Queryable.all/3
    #+end_src
    - Here, I forgot to refer User as ~alias Rumbl.Accounts.User~. After execute ~alias Rumbl.Accounts.User~. The problem solved.
      
- What is the differences between pipeline and plugs?
      
** 03-04 
1. What is user registration 
   - Apply changeset to Repo user.
   - User has username and password 
2. What happended when user do a registration    
   - We create a ~new(conn, _params_)~ in our controller to handle the get request to our url ~/users/new~.
     - In which we use ~Accounts.change_registration~ which is an wrapper for ~user.registration_changeset~.
       - In which the user's params like username, passoword are validate by changeset and applyied with ~put_change~.
3. How template and changeset are binded?
   - A changeset could be passed into template like this: ~render(conn, "new.html", changeset: changeset)~.
4. What is the differences between ~new~ and ~create~ from user_controller.ex
   - ~new~ is used in controller to handle request to ~/users/new~, it is used for rendering the form.
   - ~create~ is used in form ~Routes.user_path(@conn, :create)~, it is used for submiting the form.
** 03-05 
1. What is a context?
   - A context in Phoenix is just a module that groups functions with a shared purpose.
   - A context encapsulates all business logic for a common purpose.
   - This way, we can interact with our business logic from controllers, channels, or remote APIs, *without* having to duplicate code.
   - In other words, a controller exists to work with context functions.
   - A controller parses end user requests, calls context functions, and translates those results into something the end user can understand. In other words, *the controller's job is to translate whatever our business logic returns into something meaningfull for the user*.
   - The context doesn't know about the controller, and the controller doesn't know about the business rules.
   - When build a context, think about the way of how the context is available to the controller.
    
2. How to make a function plug available across controller and views?
   - In ~rumbl_web.ex~ import the plug function in both controller and router
     #+begin_src elixir
       def router do
         quote do
           use Phoenix.Router
           ...
           import RumblWeb.Auth, only: [authenticate_user: 2]
         end
       end

       def controller do
         quote do
           use Phoenix.Controller, namespace: RumblWeb
           ...
           import RumblWeb.Auth, only: [authenticate_user: 2]
         end
       end
     #+end_src
     - Where the ~2~ is the number of arguments expected by the ~authenticate_user~.

3. What is the relationship between view and templates 
   - A view pick all its corresponding templates and transform them into functions.
   - If a view is ~rumbl_web/view/video_view.ex~, then the templates are located at ~rumbl_web/templates/video/~.
    
4. How to find a video's associated user without creating the bundling data:
   #+begin_src elixir
     query = Ecto.assoc(video, :user)
     Repo.one(query)
   #+end_src
   - Notice, here we avoid including a complete user info into video to find out this answer.
5. When building relationship between module, we generally to avoid having cyclic dependencies. That is, prefer the one-way relationship. Here, the Video schema depends on User.

6. How to use query to restrict CRUD operation of Video are limited to current user?
    
7. Problems 
   - `Rumbl.Multimedia.Video` that was not loaded when try to associate a video with a user 
     #+begin_src elixir
       {:ok, video} = Rumbl.Multimedia.create_video(%{title: "new video", url: "http://example.com",
                                               
       alias Ecto.Changeset
       alias Rumbl.Repo

       user = Rumbl.Accounts.get_user_by(username: "zhaowei")
       changeset = video |> Changeset.change() |> Changeset.put_assoc(:user, user)
     #+end_src
     - Error message 
       #+begin_src text
         ,** (RuntimeError) attempting to cast or change association `user` from `Rumbl.Multimedia.Video` that was not loaded. Please preload your associations before manipulating them through changesets
       #+end_src
       - The error message says the Video.user is not loaded.

     - Solution, we need to preload it:
       #+begin_src elixir
         video = Rumbl.Repo.preload(video, :user)
       #+end_src
       - The ~preload~ accepts one name or a collection of association names. After Ecto tries to fetch the association, we can reference the video.user. It is great for boundling data (we include a complete user info into the video).
       - Now, we could do the associate now.
     - At last, don't forget to make changeset take effect
       #+begin_src elixir
         video = Repo.update!(changeset)
         # check user binded to that video
         video.user
       #+end_src
     - The above shows the steps to create an association between video and user. We could also do the following without the ~put_assoc~. 
       #+begin_src elixir
         video = video
         |> Changeset.change()
         |> Changeset.put_change(:user_id, user.id)
         |> Repo.update!()

         video = Repo.preload(video, :user)
       #+end_src

** 03-06
- What is context generator 
  Currently, we have met the following kind of generators 
  1) mix.ecto.gen.migration, generate only migration files
  2) mix phx.gen.html, generate migrations, schemas, context, as well as controllers, views, and templates.
  3) mix phx.gen.context,useful for generating a resource with all of its context function.
  4) mix phx.gen.schema, useful for creating a resource when we want to define the context functions by ourselves.
    
  For more information, type ~mix help GENERATOR_NAME~ in the terminal.
  
- How to add category into existing video?  
  1) We choose to use ~mix phx.gen.schema~ to generate schema.
     #+begin_src sh
       mix phx.gen.schema Multimedia.Category categories name:string
     #+end_src
     - We choose this because we probably don't need most of the generated context function.
     - It produces two related files 
       - ~category.ex~
       - ~xxx_create_categories.exs~. This file contains the migration which will create tables in db. 
  2) Edit the generated migration file to fit our need.
     - Edit the "name" field as NOT NULL and create a unique index for it.
     - At this stage, we also edit the corresponding video schema from Video.ex to create a belongs-to relationship.
  3) Use ~mix ecto.gen.migration~ to generate a migration to add the category_id to our video table.
     #+begin_src sh
       mix ecto.gen.migration add_category_id_to_video
     #+end_src
     - This command generate a migration with empty content left for us to fill.
     - Define the database contraint between videos and categories.
       #+begin_src elixir
         defmodule Rumbl.Repo.Migrations.AddCategoryIdToVideo do
           use Ecto.Migration

           def change do
             alter table(:videos) do
               add :category_id, references(:categories)
             end
           end
         end
       #+end_src
  4) Finally, migrate our database with our new migrations. 
     #+begin_src sh
       mix ecto.migrate
     #+end_src
     
  In general, we defines two migrations, one is to create categories table, another is to add the constrains on the existing video table. 
