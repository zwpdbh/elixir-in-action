* DONE How to organize code 
CLOSED: [2022-04-03 周日 13:12]
  - A module is a collection of functions, like namespace. Functions must be defined inside a module.
  - A file can contain multiple module.
  - Rules
    - Module name starts with uppercase letter and is usually formated as CamelCase style.
    - Use ~.~ in module to represent herachichy. We could also define child module inside module.
    - Function name are like abc_def.

* DONE How to call functions from other module 
CLOSED: [2022-04-03 周日 13:13]
  - We could import other module into current module, to allow us to call functions without module prefix.
  - We could use change the module's name 
    #+begin_src text
      alias IO, as: MyIO
    #+end_src
  - For example, you have a Geometry.Rectangle module. You can alias it in your client module and use a shorter name
    #+begin_src elixir
      defmodule MyModule do 
        alias Geometry.Rectangle, as: Rectange 
        
        def my_fun do
          Rectange.area(...)
        end
      end
    #+end_src
    
* DONE How to compile the code 
CLOSED: [2022-04-03 周日 13:13]
  - In Emacs, ~M-x alchemist-iex-send-last-sexp~.
  - In terminal, ~iex geometry.ex~.
  
  The code will be compiled and resulting module is loaded into the runtime.
  
* DONE How to do type specification
CLOSED: [2022-04-03 周日 13:13]
  #+begin_src elixir
    defmodule Circle do
      @pi 3.14
      
      @spec area(number) :: number 
      def area(r) do
        r * r * @pi
      end
    end
  #+end_src
  
* DONE How to get the integer from div
CLOSED: [2022-04-03 周日 13:13]
  - The division operator ~/~ always return float.
  - To get integer use 
    - ~div~ to get the integer part.
    - ~rem~ to get the remainder
  
* DONE How to define constant 
CLOSED: [2022-04-03 周日 13:13]
  - *Atom*, like ~:this_is_an_atom~

* How to use Tuples                                           :DataStructure:
  #+begin_src elixir
    person = {"bob", 25}
    
    age = elem(persion, 1) # => 25
    put_elem(person, 1, 100) # => {"bob", 100}
  #+end_src
  - Untyped structure, or record, group a *fixed* number of element together.
* How to use List                                             :DataStructure:
  #+begin_src elixir
    iex(11)>prime_numbers = [2, 3, 5, 7]
    [2, 3, 5, 7]
    iex(12)> length(prime_numbers)
    length(prime_numbers)
    4
    iex(13)> Enum.at(prime_numbers, 1)
    Enum.at(prime_numbers, 1)
    3
    iex(14)> 100 in prime_numbers
    100 in prime_numbers
    false
    iex(15)> List.replace_at(prime_numbers, 0 , 11)
    List.replace_at(prime_numbers, 0 , 11)
    [11, 3, 5, 7]
    iex(16)> prime_numbers
    prime_numbers
    [2, 3, 5, 7]
    iex(17)> new_primes = List.replace_at(prime_numbers, 0 , 11)
    new_primes = List.replace_at(prime_numbers, 0 , 11)
    [11, 3, 5, 7]
    iex(18)> new_primes = List.insert_at(new_primes, 3, 13)
    new_primes = List.insert_at(new_primes, 3, 13)
    [11, 3, 5, 13, 7]
    iex(19)> new_primes
    new_primes
    [11, 3, 5, 13, 7]
    iex(20)> new_primes = List.insert_at(new_primes, -1, 103)
    new_primes = List.insert_at(new_primes, -1, 103)
    [11, 3, 5, 13, 7, 103]
    iex(21)> [1, 2, 3] ++ [4, 5]
    [1, 2, 3] ++ [4, 5]
    [1, 2, 3, 4, 5]
    iex(22)> hd([1, 2, 3, 4])
    hd([1, 2, 3, 4])
    1
    
    iex(23)> tl([1, 2, 3, 4])
    tl([1, 2, 3, 4])
    [2, 3, 4]
    
    iex(24)> a_list = [5, :value, true]
    a_list = [5, :value, true]
    [5, :value, true]
    iex(25)> new_list = [:new_element | a_list]
    new_list = [:new_element | a_list]
    [:new_element, 5, :value, true]
  #+end_src
  
* Tuples, keywork lists, map and struct                       :DataStructure:
Two key pieces missing from tuples and lists:
- Tuples are relatively annonymous structures. Relying on specific order and number of components in tuples can create maintainance headaches.
- Lists have similar problems: the usual appraoches to list processing assume that lists are just sequences of similar parts.
  
Sometimes we want to call things out by name instead of number, or pattern matching to a specific location.  

** Mixing lists and tuples 
- How to convert two lists into a single list of tuples or vice versa?
  #+begin_src elixir
    list1 = ["Hydrogen", "Helium", "Lithium"]
    list2 = ["H", "He", "Li"]
    list3 = [1, 2 ,3]

    element_list = Enum.zip(list1, list2) # [{"Hydrogen", "H"}, {"Helium", "He"}, {"Lithium", "Li"}]
    seperate_lists = Enum.unzip(element_list) # {["Hydrogen", "Helium", "Lithium"], ["H", "He", "Li"]}
  #+end_src
  
** Keyword lists 
1. It is used to process lists of tuples containing two elements that can be considered as "key and value" pair, where the key is an atom.
2. Elixir display them in keywork list format.
   
** Map 
From lists to map: Keyword lists are a convenient way to address content stored in lists by key, but underneath, Elixir is still walking through the list. That might be OK if you have other plans for that list requiring walking through all of it, but it can be unnecessary overhead if you’re planning to use keys as your only approach to the data.

1. As key/value store 
   #+begin_src elixir
     # Dynamically sized map 
     empty_map = %{}

     # map with value
     squares = %{1 => 1, 2 => 4, 3 => 9}
     # or 
     squares = Map.new([{1, 1}, {2, 4}, {3, 9}])

     # fetch value for a given key 
     squares[2] # where 1 is the key, => 4
     squares[7] # => nil
     # or 
     Map.get(squares, 2) # => 4
     Map.get(squares, 8, :not_found) #=> :not_found, use this to specify default value.
     Map.fetch(squares, 5) #=> :error  This will distinguishly produce  
     # or raise exception 
     Map.fetch!(squares, 5)
   #+end_src
2. Power dynamically sized key/value structures, overlap Tuples' feature but let you to access fields by name
   #+begin_src elixir
     bob = %{:name => "Bob", :age => 25, :works_at => "Initech"}
     # if keys are atom, we could short as 
     bob = %{name: "Bob", age: 25, works_at: "Initech"}


     # fetch 
     bob[:works_at] # => Initech
     bod[:non_exist_key] #=> nil 
     # or use short syntax if key is atom 
     bob.age #=> 25
     # though it will get KeyError if the key is not exist


     next_bob = %{bob | age: 26}
     # => %{age: 26, name: "Bob", works_at: "Initech"}
     next_bob = %{bob | age: 26, works_at: "no_where"} # change multiple key/value
   #+end_src
   - Can only update keys exist in map!
   - *Use map to hold structured* data is very common.

** Struct (tagged map)
From maps to structs: Structs are extensions built on top of maps that provide compile-time checks and default values. 
#+begin_src elixir
  defmodule Microsoft.Azure.Storage do
    @derive {Inspect, except: [:account_key]}
    defstruct [
      :account_name,
      :account_key,
      :aad_token_provider,
      :cloud_environment_suffix,
      :is_development_factory
    ]
    ...
  end
#+end_src
- It is only possible to define a struct per module, as the struct it tied to the module itself
- Its fields:
  - could be a keyword list
  - or, a list of atoms as in this example: in this case, the atoms in the list will be used as the struct's field names and they will all default to ~nil~.
- About ~@derive~ 
  - ref: [[https://hexdocs.pm/elixir/Protocol.html#derive/3][derive/3]]
  - It is used with ~defstruct~, see [[https://hexdocs.pm/elixir/Kernel.html#defstruct/1-deriving][deriving]].
- Here, we define a custom strcut and make it could be inspected, except ~:account_key~ field.


* Protocols
1. What is a protocol 
   - It is a module in which you declare functions without implementing them.
2. Why we need protocol if we already could achieve polymorphism using patter matching?
   (Remember: polymorphism means you want behavior to vary depending on the data type.)
   1) Consider this example, we have a simple Utility module to tell use the types of input variable:
      #+begin_src elixir
        defmodule Utility do
          def type(value) when is_binary(value), do: "string"
          def type(value) when is_integer(value), do: "integer"
          # ... other implementations ...
        end
      #+end_src
      - This only works well if we implement this code and this code is not shared by multiple apps. Because there would be no easy way to extend its features.
   2) Protocol can help us:
      - The protocol implementation doesn't need to be part of any module. It means: you can implement a protocol for a type even if you can't modify the type's source code.
      - Dispatching on a protocol is available to any data type that has implemented the protocol and a protocol can be implemented by anyone, at any time.
      - So, rewrite those features as a protocol 
        #+begin_src elixir
          defprotocol Utility do
            @spec type(t) :: String.t()
            def type(value)
          end

          #  spread them over multiple files as needed
          defimpl Utility, for: BitString do
            def type(_value), do: "string"
          end

          defimpl Utility, for: Integer do
            def type(_value), do: "integer"
          end
        #+end_src
      - Functions defined in a protocol may have more than one input, but the dispatching will always be based on the data type of the first input.
3. The power of Elixir’s extensibility comes when protocols and structs are used together.
4. [[https://elixir-lang.org/getting-started/protocols.html#deriving][Deriving]]
   
   

* How to process binary
  - A binary is a chunk of byte
  - Create binary by enclosing the byte sequence
    #+begin_src elixir
      <<1, 2, 3>>
    #+end_src
    - Each number represent the value of the corresponding byte.
    - If the value is bigger than 255, it is truncated to the byte size
      #+begin_src elixir
        <<257>> #=> <<1>>
      #+end_src
  - Specify the size of each value and tell the compiler how many bits to use for that particular value 
    #+begin_src elixir
      <<234::16>> # => <<0, 234>>, used 2 bytes, the first has value 0, the second is 234 
      <<1234::32>> # => <<0, 0, 4, 210>>
    #+end_src
  - The size specifier is in *bits* and not needed to be a multiple of 8!!
    #+begin_src elixir
      <<1::4, 15::4>> # => <<31>>
    #+end_src
  - If the total size of all values is not a multiple of 8, it is called a bitstring -- a sequence of bits 
    #+begin_src elixir
      <<1::1, 0::1, 1::1>> # => <<5::size(3)>>
    #+end_src
  - Concatenate two binaries with ~<>~
    #+begin_src elixir
      <<1, 2>> <> <<3, 4>> # => <<1, 2, 3, 4>>
    #+end_src
** How to view a string's binary representation
#+begin_src elixir
  # A common trick in Elixir when you want to see the inner binary representation of a string is to concatenate the null byte <<0>> to it:
  iex> "hełło" <> <<0>>
  <<104, 101, 197, 130, 197, 130, 111, 0>>

  # Alternatively, you can view a string’s binary representation by using IO.inspect/2:
  iex> IO.inspect("hełło", binaries: :as_binaries)
  <<104, 101, 197, 130, 197, 130, 111>>
#+end_src

** How to match on a binary of unknown size 
#+begin_src elixir
  iex> <<0, 1, x::binary>> = <<0, 1, 2, 3>>
  <<0, 1, 2, 3>>
  iex> x
  <<2, 3>>
#+end_src
- Matching on arbitrary length can only be done at end of the pattern and not anywhere else.
- If you have the data which can be arbitrary bit length then you can add ~bitstring~ instead, so the pattern now looks like.  
  #+begin_src elixir
    <<header :: size(8), data :: bitstring>>
  #+end_src

** How to match n bytes in a binary 
#+begin_src elixir
  iex> <<head::binary-size(2), rest::binary>> = <<0, 1, 2, 3>>
  <<0, 1, 2, 3>>
  iex> head
  <<0, 1>>
  iex> rest
  <<2, 3>>
#+end_src

** How to pattern match on string with multibyte characters 
#+begin_src elixir
  iex> <<x::utf8, rest::binary>> = "über"
  "über"
  iex> x == ?ü
  true
  iex> rest
  "ber"
#+end_src
- Therefore, when pattern matching on strings, it is important to use the utf8 modifier.

** Example: chunk from PNG 
- Chunk format 
  #+begin_src text
    +--------------+----------------+-------------------+
    |  Length (32) | Chunk type (32)| Data (Length size)|
    +--------------+----------------+-------------------+
    |   CRC (32)   |
    +--------------+
  #+end_src
- Pattern matching the chunk format 
  #+begin_src elixir
    <<length     :: size(32),
      chunk_type :: size(32),
      chunk_data :: binary - size(length),
      crc        :: size(32),
      chunks     :: binary>>
  #+end_src
  - Another way of defining n byte length is ~binary - size(n)~. 
  - =Note=: we matched ~length~ in pattern and used in the pattern as well. In Elixir pattern matching you can use the assigned variable in the pattern following it, thats why we are able to extract the ~chunk_data~ based on the ~length~.
* How to represent string 
  - String in elixir is either a binary or a list type.
  - String inter -- evaluate values in string template
    #+begin_src elixir
      "embedded expression: #{1 + 3}" #=>"embedded expression: 4"
    #+end_src
  - How to include quote inside string
    #+begin_src elixir
      ~s("embedded expression": #{1 + 3}) #=> "\"embedded expression\": 4"
      
      """ 
      embedded expression: "#{1 + 3}" 
      """
      # => "embedded expression: \"4\"\n"
    #+end_src
  - Aother way to represent string is use single-quote 
    #+begin_src elixir
      'ABC'
      [65, 66, 67] 
      # => they both produce 'ABC'
    #+end_src
    - The runtime doesn't distinguish between a list of integers and a character list.

* How to convert between binary string to character list 
  - binary string is represent using ~""~ while character list is represent as ~''~.
  - Use binary string as much as possbile
  - Convert 
    #+begin_src elixir
      String.to_charlist("ABC")       
    #+end_src

* How to define Lambda function and use it 
- basic lambda 
  #+begin_src elixir
    square = fn x ->
      x * x
    end

    iex(2)> square.(24)
    square.(24)
    576
  #+end_src
  - The dot operator is to make the code explicit such that you know an anonymous function is being called.
  - ~square(5)~ will be a named function defined somewhere in the module.
- *Capture* makes us to make full function qualifier as lambda 
  #+begin_src elixir
    Enum.each([1, 2, 3, 4], &IO.puts/1)

    iex(4)> Enum.each([1, 2, 3, 4], &IO.puts/1)
    1
    2
    3
    4
    :ok
  #+end_src
  
- The closure capture *doesn't* affect the previous defined lambda that references the same symbolic name
  #+begin_src elixir
    outside_var = 5
    lambda = fn -> IO.puts(outside_var) end
    outside_var = 6
    lambda.() #=> 5
  #+end_src
  
* How to use other types 
1) range
2) keyword list 
   - A list of pair, where the first one is atom.
   - Often used for small key-value structures.
   - Often used as the last optional argument when define a function.
3) MapSet, a set implementation
4) Time and date
   #+begin_src elixir
     date = ~D[2008-09-30]
     time = ~T[11:59:12]
     naive_datetime = ~N[2018-01-31 11:59:12.000007]
   #+end_src
5) *IO lists*
   - Special for incrementally building output that will be forwarded to an I/O service.
   - Appending to an IO list is O(1), very useful to incrementally build a stream of bytes 
     #+begin_src elixir
       iolist = []
       iolist = [iolist, "This"]
       iolist = [iolist, "is"]
       iolist = [iolist, "Amazing"]

       iex(20)> iolist = []
       iex(21)> [[], "This"]
       iex(22)> [[[], "This"], "is"]
       iex(23)> [[[[], "This"], "is"], "Amazing"]
       iex(24)> IO.puts(iolist)
       IO.puts(iolist)
       ThisisAmazing
       :ok
     #+end_src

* How to use lib from mix 
1) In mix.exs, add the lib into ~deps~.
2) In iex, run ~recompile()~ or disconnect from iex and re-run alchemist-iex-project-run: "C-c a i p".
3) Test the example of lib in iex shell.
4) If we want to shortcut the name, we could use ~alias~ to create short name.
* How to check the and load additional code paths 
- load additional code path from command-line when started erlang runtime 
  #+begin_src elixir
    $ iex -pa my/code/path -pa another/code/path # from command-line to load additional code path 
  #+end_src
- once start runtime, check current loaded path 
  #+begin_src elixir
    :code.get_path # check path 
  #+end_src  
  
* How to dynamically call a function  
#+begin_src elixir
  apply(IO, :puts, ["Dynamic function call."])
#+end_src

* How to run a single script
- Create ~.exs~ file 
  #+begin_src elixir :file script.exs
    defmodule MyModule do
      def run  do
        IO.puts("Called Mymodule.run")
      end
    end

    # Code outside of a module is executed immediately
    MyModule.run
  #+end_src

- On terminal 
  #+begin_src sh
    elixir script.exs
  #+end_src
  - With ~--no-halt~, it will make the BEAM instance keep running. Useful when your script start other concurrent tasks.

* How to get current time 
#+begin_src elixir
  iex(28)> {_, time} = :calendar.local_time()
  {{2022, 2, 11}, {13, 32, 10}}
  iex(29)> time 
  time 
  {13, 32, 10}
#+end_src

* How to handle exception error in guard
- If an error is raised from inside the guard, it won't be propagated. And the guard expression will return false. The corresponding clause won't match.

* How to match the content of variable
#+begin_src elixir
  iex(30)> expected_name = "bob"
  expected_name = "bob"
  "bob"
  iex(31)> {^expected_name, age} = {"bob", 25}
  {^expected_name, age} = {"bob", 25}
  {"bob", 25}
  iex(32)> age 
  age 
  25
#+end_src


* How to check the type of a variable
  - From REPL 
    #+begin_src elixir
      iex(10)> i x
      i x
      Term
        1
      Data type
        Integer
      Reference modules
        Integer
      Implemented protocols
        IEx.Info, Inspect, List.Chars, String.Chars
    #+end_src
  - From code 
    #+begin_src elixir
      defmodule Util do
          def typeof(a) do
              cond do
                  is_float(a)    -> "float"
                  is_number(a)   -> "number"
                  is_atom(a)     -> "atom"
                  is_boolean(a)  -> "boolean"
                  is_binary(a)   -> "binary"
                  is_function(a) -> "function"
                  is_list(a)     -> "list"
                  is_tuple(a)    -> "tuple"
                  true           -> "idunno"
              end    
          end
      end
      
      cases = [
          1.337, 
          1337, 
          :'1337', 
          true, 
          <<1, 3, 3, 7>>, 
          (fn(x) -> x end), 
          {1, 3, 3, 7}
      ]
      
      Enum.each cases, fn(case) -> 
          IO.puts (inspect case) <> " is a " <> (Util.typeof case)
      end
    #+end_src

* How to chain multiple pattern matching
  #+begin_src elixir
    defmodule ChainPattern do
      # define some helper function
      def extract_login(%{"login" => login}) do
        {:ok, login}
      end
      def extract_login(_) do
        {:error, "login missed"}
      end
    
      def extract_email(%{"email" => email}) do
        {:ok, email}
      end
      def extract_email(_) do
        {:error, "email missed"}
      end
    
      def extract_password(%{"password" => password}) do
        {:ok, password}
      end
      def extract_password(_) do
        {:error, "password missed"}
      end
    
    
      def extract_info(submitted) do
        with {:ok, login} <-extract_login(submitted),
          {:ok, email} <-extract_email(submitted),
          {:ok, password} <-extract_password(submitted) do
          {:ok, %{login: login, email: email, password: password}}
        end
      end
    end
    
    submitted = %{
      "login" => "alice",
      "email" => "some_email",
      "password" => "password",
      "other_field" => "some_value",
      "yet_another_not_wanted_field" => "..."
    }
    
    # iex(20)> ChainPattern.extract_info(submitted)
    # ChainPattern.extract_info(submitted)
    # {:ok, %{email: "some_email", login: "alice", password: "password"}}
  #+end_src
* How to build abstraction 
  - Princple
    - Module is used as the abstraction over the data type.
    - Modifier functions should return data of the same type. 
    - Query functions expect an instance of the data abstraction as the first argument and return another type of information.
* How to update hierachical data 
  - In general
    - We can't directly modify part of it that resides deep in its tree.
    - We have to walk down the tree to particular part that needs to be modified, and then transform it and all of its ancestors.
    - The result is a copy of the entire model.
  - Useful macros from Kernel:
    - ~put_in/2~
    - ~put_in/3~
    - ~get_in/2~
    - ~update_in/2~
    - ~get_and_update_in/2~
  - Those macros rely on the *Access* module. So, if we want our custom data to work with Access, we need to implement a couple of function required by *Access* contract. See: [[https://hexdocs.pm/elixir/Access.html][Access behaviour]]


* How to register a process
  - If you know there will always be only one instance of some type of server, you can give the process a local name and use that name to send messages to the process. The name is called local because it has meaning only in the currently running BEAM instance.
  - Using the registered server is much simpler becaue we don't need to pass server pid around through interface.
  - Example
    #+begin_src elixir
      Process.register(self(), :some_name)
      
      send(:some_name, :msg)
      receive do
        msg -> IO.puts("received #{msg}")
      end
    #+end_src
* How to handle unlimited process mailbox problem
  - If a message is not match, it will be stored in mailbox with unlimited number. If we don't process them, they will slow down the system and even crash the system when all memory is consumed.
  - For each server process, we should introduce a *match-all* receive clause that deals with unexpected kind of messages.

* How to implement a general server process
  - In general, there are 5 things to do 
    - spawn a seperate process
    - loop to infinite in that process  
    - receive message
    - send message back to the caller
    - maintain state


* How to debug
  - Check the representation of a struct 
    #+begin_src elixir
      Fraction.new(1,4)
      |> IO.inspect() 
      |> Fraction.add(Fraction.new(1,4))
      |> IO.inspect()
      |> Fraction.value()
      
      # %Fraction{a: 1, b: 4}
      # iex(70)> %Fraction{a: 1, b: 4}
      # %Fraction{a: 1, b: 4}
      # iex(71)> %Fraction{a: 8, b: 16}
      # iex(72)> %Fraction{a: 8, b: 16}
      # %Fraction{a: 8, b: 16}
      # iex(73)> 0.5
    #+end_src

* How to get the number of currently running process 
#+begin_src elixir
  :erlang.system_info(:process_count)
#+end_src
* How state is maintained in server process 
- In plain server process implementation
  - State is passed as argument in loop clause. State is modified (new state) as the result of callback module's message handling.
  - This means the callback module's ~handle_call/2~ and ~handle_cast/2~ need to pass state as argument
- In GenServer 
  - state is passed in from callback module's interface as argument
  - state is passed in in ~handle_cast/2~ as argument

* How to create a singleton of a module
- Implement ~GenServer~ in your module 
  #+begin_src elixir
    def start do
      # locally register the process, make sure only one instance of the database process.
      GenServer.start(__MODULE__, nil, name: __MODULE__)
    end
  #+end_src
* Some notes 
  - Always keep in mind that a Boolean is just an atom that has a value of true or false.
  - short-circuit operators: ~||~, ~&&~, ~!~.
    - ~||~ returns the first expression that isn't falsy.
      - Use for like 
        #+begin_src elixir
          read_cache || read_from_disk || read_from_database
        #+end_src
    
* How to use elixir to request access token 
#+begin_src elixir
  defmodule Script do
    @secret "84G7Q~JiELHPu3XuNKqckEB1eavVnMpHmnoZh"
    @client_id "2470ca86-3843-4aa2-95b8-97d3a912ff69"
    @tenant "72f988bf-86f1-41af-91ab-2d7cd011db47"
    @scope "https://microsoft.onmicrosoft.com/3b4ae08b-9919-4749-bb5b-7ed4ef15964d/.default"  
    @moduledoc """
    A HTTP client for doing RESTful action for DeploymentService.
    """
    def request_access_token() do
      url = "https://login.microsoftonline.com/#{@tenant}/oauth2/v2.0/token"

      case HTTPoison.post(url, urlencoded_body(), header()) do
        {:ok, %HTTPoison.Response{status_code: 200, body: body}}  ->

          body
          |> Poison.decode
          |> fetch_access_token
          # |> IO.puts

        {:ok, %HTTPoison.Response{status_code: 404}} ->
          IO.puts "Not found :("
        {:error, %HTTPoison.Error{reason: reason}} ->
          IO.inspect reason      
      end
    end

    def trigger_workflow(token) do
      definition_name = "AuroraK8sDynamicCsi"
      url = "https://xscndeploymentservice.westus2.cloudapp.azure.com/api/Workflow?definitionName=#{definition_name}"
      HTTPoison.post(
        url,
        json_body(),
        [
          {"Content-type", "application/json"},
          {"Authorization", "Bearer #{token}"},
          {"accept", "text/plain"}])
    end

    def test() do
      request_access_token()
      |> trigger_workflow
    end

    def fetch_access_token({:ok, %{"access_token" => access_token}}) do
      access_token
    end

    def header() do
      [{"Content-type", "application/x-www-form-urlencoded"}]
    end
  
    def urlencoded_body() do
      %{"client_id" => @client_id,
        "client_secret" => @secret,
        "scope" => @scope,
        "grant_type" => "client_credentials"}
      |> URI.encode_query
    end

    def json_body() do
      %{
        SubscriptionId: "33922553-c28a-4d50-ac93-a5c682692168",
        DeploymentLocation: "East US 2 EUAP",
        Counter: "1",
        AzureDiskStorageClassAsk: "Random",
        AzureDiskPvcSize: "13"
      }
      |> Poison.encode!
    end
  end
#+end_src
* How to do OAuth
- ref: [[https://github.com/danschultzer/pow][Pow is a robust, modular, and extendable authentication and user management solution for Phoenix and Plug-based apps.]]

* How to check a module's available functions 
- <ModuleName>.__info__(:functions)
- Example 
  #+begin_src elixir
    KeyValueStore.__info__(:functions)
    [get: 2, handle_call: 2, handle_cast: 2, init: 0, put: 3, start: 0]
  #+end_src

* How to represent a two dimensional board game?
- ref: [[https://blog.danielberkompas.com/2016/04/23/multidimensional-arrays-in-elixir/][Multidimensional Arrays in Elixir]]
- ref: [[https://elixirforum.com/t/how-to-make-proper-two-dimensional-data-structures-in-elixir/872/16][https://elixirforum.com/t/how-to-make-proper-two-dimensional-data-structures-in-elixir/872/16]]
* Dynamic dispatch 
- Ref: [[https://dnlserrano.dev/2019/12/21/behaviours-and-dynamic-dispatch.html][Behaviours and Dynamic dispatch]]
  - It shows how to use Behaviours to transform a dynamic dispatch on function to dynamic dispath on module.

* Difference between alias, use, require and import in Elixir 
1) ~alias~ is used to give shortcut names for a model.
2) ~import~: Aliases are great for shortening module names but what if we use functions from given module extensively and want to skip using module name part? 
   ~import~ imports all public functions and macros from given module.
3) ~require~ is like import + alias while different from either ~import~ or ~alias~. 
   - It is used like ~alias~, but different from it that it will compile module first.
   - So, if a module contains a macro, and we want to use as SomeModule.SomeMacro, ~require~ will work but not ~alias~.
4) ~use~ allow us to *inject* any code in the current module. 
   
* Elixir with Phoenix notes 
** 02-24 
- create a project and start 
  #+begin_src sh
    mix phx.new hello
    cd hello/
    cd assets/
    npm install
    cd ..
    mix ecto.create # create db configuration
    mix phx.server
    # or 
    iex -S mix phx.server
  #+end_src
  - visit http://localhost:4000
- A new feature: print a string when you load a specific URL 
  All actions is done in ~lib/hello_web~
  1) Map requests coming in to a specific URL
     - Edit router, specify the controller, and a action name.
  2) tie a URL to a function on a controller
     - Define a function in controller
     - The name of the function should match the action name specified on router
  3) Tie that function to a view
     - But how how bind controller with view?
       - We defined a module ~HelloWeb.HelloView~
       - That file doesn閳ユ獩 actually do any work beyond tying the view for world with some code to render a template. We閳ユ獟l rely on the defaults to render a template.
     - Inside the action function from controller, we specify the render with a template
  4) About request parameters
     - Defined in router
     - Extract out in controller with patter matching
       - Notice the convention from string to atom
     - Use it template(<action_name>.html.eex) with "@<parameter_name>".
- About pattern matching, string and atom 
  #+begin_src elixir
    # from top to bottom, be shorthanded
    [{:name, name}]
    [:name => name]
    [name: name]
    name: name # if it is used as the last argument of a function
  #+end_src
- Problems about starts project as ~iex -S mix phx.server~ from Emacs 
  - Make sure the Emacs is running as Administrator.
  - If it has postgres issue, go to the project root, and re-run ~mix ecto.create~.
  - When start Phoenix project from Emacs using alchemist, the default command is ~iex -S mix~, we need to edit to ~iex -S mix phx.server~
    
- How to check Phoenix version 
  cd into mix project root folder, run 
  #+begin_src sh
    mix phx.new --version
  #+end_src
    
  
** 02-27
   - A view in Phoenix is just a module, and templates are just functions.
   - How to persistent out model data with database?
     1) Modify models from lib: for example, ~lib/rumbl/accounts/user.ex~.
        - This is for schema definition.
     2) run ~ecto.gen.migration~
        #+begin_src sh
          mix ecto.gen.migration create_users
        #+end_src
        - This will create migration ~<timesteamp>_create_users.exs~ file in path ~priv/migrations/~. 
        - Edit the generated ~.exs~ file to define. This is for use code to operator database to create corresponding tables.
        - In general, we write elixir code to create/update table schema.
     3) run ~mix ecto.migrate~
        - In this step, the actual table is created. 

          
     In general, 3 steps 
     - In lib modify our model 
       - Define schema using ~Ecto.Schema~
       - Define corresponding changeset.
     - Generate migration file, in which we define database operations.
     - Execute migration, by ~mix ecto.migrate~.
       
** 02-28
- After 
- Use ~mix phx.routes~ to check all available routes in our web application.
  
  


** 03-01
- After migration (create user table, we could test it from iex shell)
  #+begin_src elixir
    alias Rumbl.Repo
    alias Rumbl.Accounts.User

    Repo.insert(%User{name: "Jose", username: "josevalim"})
    Repo.insert(%User{name: "Bruce", username: "redrapids"})
    Repo.insert(%User{name: "Chris", username: "mccord"})
  #+end_src
  
- Check ~Phoenix.HTML.FormData~ contract to understand how the changes in the changeset available to the form.
  
- How to refer to specific routes in the application
  - Use ~YourApplication.Router.Helpers~. In fact, phx help use with ~alias RumblWeb.Router.Helpers, as: Routes~.
  - So, we can get any route through ~Routes.some_path~.

- Install application as dependencies
  - edit ~mix.exs~
    
  - ~mix deps.get~

- Check point01 
  1) Install password feature dependencies
  2) In ~user.ex~
     - define schema for password and password_hash
     - create our ~registration_changeset~
  3) Test in iex shell 
     #+begin_src elixir
       alias Rumbl.Accounts.User
       alias Rumbl.RumblWeb.Router.Helpers, as: Routes

       # this one is not valid 
       changeset = User.registration_changeset(%User{}, %{username: "max", name: "Max", password: "123"})

       # this one is valid 
       changeset = User.registration_changeset(%User{}, %{username: "max", name: "Max", password: "asecret"})
     #+end_src
     
- Check point02 
  - To fix already existing user to make them have valid password
    #+begin_src elixir
      recompile()
      alias Rumbl.Repo

      for u <- Repo.all(User) do 
          Repo.update!(User.registration_changeset(u, %{password: "gghh3344"}))
      end
    #+end_src
    - 

- Check point03 
  1) At this point, all users shall meet the requirement: new user registration need to have passworld.
  2) In Account module, use User module's registration changeset. (model)
  3) In user_controller, use exposed function from Account module.
  4) Modify new user html to provide slot for pasword. (view)

- Check point04 
  Check if there is a new user in the session and store it in ~conn.assigns~ for every incoming request. In other words, we need to prevent user to access certain action when there is no session record.
  - loading data from session
  - use it to restric user access
    
- Check point05 
  Add a mechanism to log the users in.
  - create login function in auth.ex
    - assigns current user
    - put session and configuration_session to reuse.    
  - use login function in user controller

    
- Problem01
  #+begin_src text
    lib/rumbl/accounts.ex:48: Users.__struct__/1 is undefined, cannot expand struct Users. Make sure the struct name is correct. If the struct name exists and is correct but it still cannot be found, you likely have cyclic module usage in your code
  #+end_src
  - When I add a new user, it shows this.
  - Following error message, I could solve this: there is a typo in accounts.ex which I use ~%Users{}~ instead of should use ~%User{}~.
    
** 03-02 
- Check Point 01 
  - Expose a function to validate username and password.
  - Use RESTful session API for 
    - GET for new session login form
    - POST for login
    - DELETE for logout
      
      
- Check Point 02 
  - Change the layout of the application to handle the new user features
    
- Problem01
  - When I go home to execute steps from check point02. I got error:
    #+begin_src text
      iex(3)> for u <- Repo.all(User) do 
          Repo.update!(User.registration_changeset(u, %{password: "tmppass"}))
      end
      ...(3)> ...(3)> ** (Protocol.UndefinedError) protocol Ecto.Queryable not implemented for User of type Atom, the given module does not exist. This protocol is implemented for the following type(s): Atom, BitString, Ecto.Query, Ecto.SubQuery, Tuple
          (ecto 3.7.1) lib/ecto/queryable.ex:40: Ecto.Queryable.Atom.to_query/1
          (ecto 3.7.1) lib/ecto/repo/queryable.ex:16: Ecto.Repo.Queryable.all/3
    #+end_src
    - Here, I forgot to refer User as ~alias Rumbl.Accounts.User~. After execute ~alias Rumbl.Accounts.User~. The problem solved.
      
- What is the differences between pipeline and plugs?
      
** 03-04 
1. What is user registration 
   - Apply changeset to Repo user.
   - User has username and password 
2. What happended when user do a registration    
   - We create a ~new(conn, _params_)~ in our controller to handle the get request to our url ~/users/new~.
     - In which we use ~Accounts.change_registration~ which is an wrapper for ~user.registration_changeset~.
       - In which the user's params like username, passoword are validate by changeset and applyied with ~put_change~.

3. What is the differences between ~new~ and ~create~ from user_controller.ex
   - ~new~ is used in controller to handle request to ~/users/new~, it is used for rendering the form.
   - ~create~ is used in form ~Routes.user_path(@conn, :create)~, it is used for submiting the form.
5. What is login for a user 
   - A user is login when the session contains the user's username.
6. How to implement authentication feature (login and logout)
   - We implement authentication as a plug. So, we can add it to a plug pipeline for our router.
   - There are two kinds of plugs, one is function plugs and another is module plugs. When to prefer module plug over function plug?
     - When we want to share a plug across more than one module.
   - In module plug, there are two methods matters:
     - init
     - call
       - its second argument is the result of ~init~.
       - its first argument is the ~conn~ which is ~Plug.Conn~ struct.
     So, we need to import ~import Plug.Conn~.
   - The plug for authentication implementation:
     - Store the user ID in the session every time a user registers or a user login.
     - Check if there is a new user in the session and store it in the conn.assign for every incoming request.
       - Do this in our plug ~call~.
** 03-05 
1. What is a context?
   - A context in Phoenix is just a module that groups functions with a shared purpose.
   - A context encapsulates all business logic for a common purpose.
   - This way, we can interact with our business logic from controllers, channels, or remote APIs, *without* having to duplicate code.
   - In other words, a controller exists to work with context functions.
   - A controller parses end user requests, calls context functions, and translates those results into something the end user can understand. In other words, *the controller's job is to translate whatever our business logic returns into something meaningfull for the user*.
   - The context doesn't know about the controller, and the controller doesn't know about the business rules.
   - When build a context, think about the way of how the context is available to the controller.
    
2. How to make a function plug available across controller and views?
   - In ~rumbl_web.ex~ import the plug function in both controller and router
     #+begin_src elixir
       def router do
         quote do
           use Phoenix.Router
           ...
           import RumblWeb.Auth, only: [authenticate_user: 2]
         end
       end

       def controller do
         quote do
           use Phoenix.Controller, namespace: RumblWeb
           ...
           import RumblWeb.Auth, only: [authenticate_user: 2]
         end
       end
     #+end_src
     - Where the ~2~ is the number of arguments expected by the ~authenticate_user~.

3. What is the relationship between view and templates 
   - A view pick all its corresponding templates and transform them into functions.
   - If a view is ~rumbl_web/view/video_view.ex~, then the templates are located at ~rumbl_web/templates/video/~.
    
4. How to find a video's associated user without creating the bundling data:
   #+begin_src elixir
     query = Ecto.assoc(video, :user)
     Repo.one(query)
   #+end_src
   - Notice, here we avoid including a complete user info into video to find out this answer.
5. When building relationship between module, we generally to avoid having cyclic dependencies. That is, prefer the one-way relationship. Here, the Video schema depends on User.

6. How to use query to restrict CRUD operation of Video are limited to current user?
    
7. Problems 
   - `Rumbl.Multimedia.Video` that was not loaded when try to associate a video with a user 
     #+begin_src elixir
       {:ok, video} = Rumbl.Multimedia.create_video(%{title: "new video", url: "http://example.com",
                                               
       alias Ecto.Changeset
       alias Rumbl.Repo

       user = Rumbl.Accounts.get_user_by(username: "zhaowei")
       changeset = video |> Changeset.change() |> Changeset.put_assoc(:user, user)
     #+end_src
     - Error message 
       #+begin_src text
         ,** (RuntimeError) attempting to cast or change association `user` from `Rumbl.Multimedia.Video` that was not loaded. Please preload your associations before manipulating them through changesets
       #+end_src
       - The error message says the Video.user is not loaded.

     - Solution, we need to preload it:
       #+begin_src elixir
         video = Rumbl.Repo.preload(video, :user)
       #+end_src
       - The ~preload~ accepts one name or a collection of association names. After Ecto tries to fetch the association, we can reference the video.user. It is great for boundling data (we include a complete user info into the video).
       - Now, we could do the associate now.
     - At last, don't forget to make changeset take effect
       #+begin_src elixir
         video = Repo.update!(changeset)
         # check user binded to that video
         video.user
       #+end_src
     - The above shows the steps to create an association between video and user. We could also do the following without the ~put_assoc~. 
       #+begin_src elixir
         video = video
         |> Changeset.change()
         |> Changeset.put_change(:user_id, user.id)
         |> Repo.update!()

         video = Repo.preload(video, :user)
       #+end_src

** 03-06
1. What is context generator 
   Currently, we have met the following kind of generators 
   1) mix.ecto.gen.migration, generate only migration files
   2) mix phx.gen.html, generate migrations, schemas, context, as well as controllers, views, and templates.
   3) mix phx.gen.context,useful for generating a resource with all of its context function.
   4) mix phx.gen.schema, useful for creating a resource when we want to define the context functions by ourselves.
    
   For more information, type ~mix help GENERATOR_NAME~ in the terminal.
  
2. How to add category into existing video?  
   1) We choose to use ~mix phx.gen.schema~ to generate schema.
      #+begin_src sh
        mix phx.gen.schema Multimedia.Category categories name:string
      #+end_src
      - We choose this because we probably don't need most of the generated context function.
      - It produces two related files 
        - ~category.ex~
        - ~xxx_create_categories.exs~. This file contains the migration which will create tables in db. 
   2) Edit the generated migration file to fit our need.
      - Edit the "name" field as NOT NULL and create a unique index for it.
      - At this stage, we also edit the corresponding video schema from Video.ex to create a belongs-to relationship.
   3) Use ~mix ecto.gen.migration~ to generate a migration to add the category_id to our video table.
      #+begin_src sh
        mix ecto.gen.migration add_category_id_to_video
      #+end_src
      - This command generate a migration with empty content left for us to fill.
      - Define the database contraint between videos and categories.
        #+begin_src elixir
          defmodule Rumbl.Repo.Migrations.AddCategoryIdToVideo do
            use Ecto.Migration

            def change do
              alter table(:videos) do
                add :category_id, references(:categories)
              end
            end
          end
        #+end_src
   4) Finally, migrate our database with our new migrations. 
      #+begin_src sh
        mix ecto.migrate
      #+end_src
     
   In general, we defines two migrations, one is to create categories table, another is to add the constrains on the existing video table.

3. How to regret a just did migration?
   - We could use ~mix ecto.rollback~ to migration down.
   - For example, we just did some migration. But we found we need to add an extra field for our just created table.
   - We could use ~mix ecto.rollback~ to revert the migration. Edit the change, then do ~mix ecto.migrate~ to apply the changes.
4. Seeding and associating categories
   - How to use script to populate our data while maintain database constrains
   - How to associate videos and categories
     - Fetch all categories name and IDs from db.
     - Sort them by name
     - Pass them into view as "select" input.
5. Problem: my categories currently don't have unique value even when I already specify the unique contraint from schema.
   - The way I created table categories using migration 
     #+begin_src elixir
       defmodule Rumbl.Repo.Migrations.RecreateCategory do
         use Ecto.Migration

         def change do
           create table(:categories) do
             add :name, :string, null: false

             timestamps()
           end

           create unique_index(:categories, [:name])
         end
       end
     #+end_src

   - The way how I add Category using changeset 
     - In multimedia.ex 
       #+begin_src elixir
         alias Rumbl.Multimedia.Category

         def create_category!(name) do
           %Category{}
           |> Category.changeset(%{name: name})

           Repo.insert!(%Category{name: name}, on_conflict: :nothing)
         end
       #+end_src

     - In category.ex 
       #+begin_src elixir
         defmodule Rumbl.Multimedia.Category do
           use Ecto.Schema

           import Ecto.Changeset
           import Ecto.Query

           schema "categories" do
             field :name, :string

             timestamps()
           end

           def changeset(category, attrs) do
             category
             |> cast(attrs, [:name])
             |> validate_required([:name])
             |> unique_constraint(:name)    
           end
         end

       #+end_src


** 03-07 
- How to delete all created categories
  - Currently, there are multiple duplicated values. I plan to delete all of them and create some values.
  - Delete existing categories
    #+begin_src elixir
      alias Rumbl.Repo
      alias Rumbl.Multimedia.Category

      import Ecto.Query, only: [from: 2]

      query = Category
      Rumbl.Repo.delete_all(Category)
    #+end_src
  - Populate category 
    #+begin_src elixir
      alias Rumbl.Multimedia

      for category <- ~w(Action Drama Romance Comedy Sci-fi) do
        Multimedia.create_category!(category)
      end
    #+end_src
  - Why my changeset doesn't impose constraint?
    #+begin_src elixir
      import Ecto.Changeset

      alias Rumbl.Repo

      alias Rumbl.Multimedia.Video
      alias Rumbl.Multimedia.Category

      def create_category!(name) do
        %Category{}
        |> create_category_changeset(%{name: name})
        Repo.insert!(%Category{name: name}, on_conflict: :nothing)
      end

      def create_category_changeset(category, attrs) do
        category
        |> cast(attrs, [:name])
        |> validate_required([:name])
        |> unique_constraint(:name)
      end
    #+end_src
    - Test it with 
      #+begin_src elixir
        alias Rumbl.Multimedia
        Multimedia.create_category!("Action")

        alias Rumbl.Multimedia.Category
        Multimedia.create_category_changeset(%Category{}, %{name: "Action"})
      #+end_src
      - It should shows false, but the valid is true...
        
- How to delete the category table and create it again?
  - ref: [[https://elixirforum.com/t/how-to-delete-drop-table/40018/6][How to delete/drop table?]]
  - Steps 
    1) Generate a migration
       #+begin_src sh
         mix ecto.gen.migration drop_category
       #+end_src
       - This command will contain a ~change~ function. By adding our custom logic into that ~change~ function, we could apply custom changes.
    2) Add change function to the migration 
       #+begin_src elixir
         defmodule Rumbl.Repo.Migrations.DropCategory do
           use Ecto.Migration

           def change do
             drop table("categories"), mode: :cascade
           end
         end
       #+end_src
    3) Apply those changes 
       #+begin_src sh
         mix ecto.migrate
       #+end_src
  
** 03-10
- After we define our model using schema, how migration understand that model?
  - It doesn't. We have to define the migration content by ourselves.
  - For example:
    - In our account/user.ex, we defined the following models 
      #+begin_src elixir
        defmodule Rumbl.Accounts.User do
          use Ecto.Schema
          import Ecto.Changeset

          schema "users" do
            field(:name, :string)
            field(:username, :string)
            timestamps()
          end
        end
      #+end_src
    - mix ecto.gen.migration create_users
      - This will generate migration file named like: creating priv/repo/migrations/20180315023132_create_users.exs
    - In that create_users.exs, the change is empty. We have to define how to operation the database.
      So, we have to define how to create table, create attributes, and create indexes.
    - At last, we use ~mix ecto.migrate~ to migrate up the database.
    
** 03-12 
- How the test cases could know our helper functions?
  - We define our helper functions in Rumbl.TestHelpers module.
  - We then import them globally in Rumbl.DataCase module in ~test/support/data_case.ex~.
** 03-18
- How to drop a entire dev database and recreate all associated tables?
  1) mix ecto.drop rumbl_dev --force-drop
  2) mix ecto.create
  3) mix ecto.migrations (Use this command to check the current migrations available.)
  4) mix ecto.migrate
    
** 03-19 
- How the js code in ~assets/js~ folder are available to the pages(template)
- See, chapter10
  
** 03-21
- How to quickly generate model (including schema and database change migration)
  #+begin_src sh
    mix phx.gen.schema Multimedia.Annotation annotations \
        body:text at:integer \
        user_id:references:users \
        video_id:references:videos
  #+end_src
  - This command is create model annotation which including 4 fields 
    - body
    - at
    - user_id
    - video_id
  - The result of running this command are two files one is migration_change. Another is annotation.ex file which changeset and schema.
  - *Notice*, the schema here doesn't wire annotation with user or video.
  - To bind relationship between annotation with user and video. We need to do it with manually with careful decision.
  - *Don't forgot* to modify the corresponding video or user's schema to make space for annotation.
  

* Elixir code example 
** [[https://elixirforum.com/t/pattern-matching-encoded-json/2950][pattern matching encoded json]]
* How to implement network protocols 
** TODO ref: [[https://www.youtube.com/watch?v=-FiQhkV7JYk][Going low level with TCP sockets and :gen_tcp - Orestis Markou - ElixirConf EU 2018]] 
** TODO ref: [[https://github.com/spawnfest/wishvpn][wishvpn -- using Erlang]]
** TODO ref: [[https://github.com/meh/elixir-socket][Elixir sockets made decent]]
** ref: [[https://www.youtube.com/watch?v=UoxzAPBVuQs][Building a MySQL Database Driver in Elixir by Mohd Maqbool]]

* How to implement workflow 
** Refs 
- [[https://hexdocs.pm/gen_stage/GenStage.html][Stages are data-exchange steps that send and/or receive data from other stages.]]
- [[https://elixirforum.com/t/suggestions-for-workflow-automation-sequencing/32149][Suggestions for workflow & automation sequencing]]
- [[https://www.youtube.com/watch?v=aPh4Z3SioB8][Dataflow Programming]]
  
** Requirements 
- Workflow must be composed from other workflow. This means one step in a workflow could also be a workflow by itself.
- Workflow could be defined at runtime (probably from external sources)
- Workflows can be executed as trees.
  #+begin_src text
                 +-------+      +-------+
                 |       |      |       |
        +-------->   F   +------>   B   |
        |        |       |      |       |
        |        +-------+      +-------+
    +---+---+    +-------+      +-------+
    |       |    |       |      |       |
    |   X   +---->   Y   +----->+   Z   |
    |       |    |       |      |       |
    +-------+    +-------+      +-------+
  #+end_src
  - F, and Y depend on X, so F and Y could be run only when X is true.
  - ANd F and Y are independent to each other. They can run in parallel.
  
** My notes 
- General idea 
  - The idea is that you build a model of the computation as a data structure separate from the execution at runtime, how you implement this can be optimized depending on your domain.  
- It seems there are two approaches 
  1. Module each step in workflow as simple functions. 
     - Every workflow is just a function in its most basic form.
     - Functions could be chained by ~|>~ operator as another function's definition.
     - The workflow could be defined at runtime as MFA (Module, Function, Arguments) tuples.
       #+begin_src elixir
         apply(module, function, arguments)
       #+end_src
     - A simple example could be 
       #+begin_src elixir
         defmodule St.Workflow do
  
           def step01(params) do
             IO.puts("step01")
             params
           end


           def step02(params) do
             IO.puts("step02")
             params
           end

           def step03(params) do
             IO.puts("step03")
             params
           end

           def workflow01(params) do
             params
             |> step01
             |> step02
           end


           def workflow02(params) do
             params
             |> step02
             |> step03
           end

           def workflow03(params) do
             params
             |> workflow01
             |> workflow02
           end

           def execute([head | tail], [params]) do
             apply(St.Workflow, String.to_atom(head), [params])
             execute(tail, [params])
           end

           def execute([], [params]) do
             params
           end
         end

         St.Workflow.execute(["workflow01", "workflow03"], [%{}])
       #+end_src
     
  2. Module each step in workflow as a elixir process which receive and send messages.
       


* Preparation for my website 
** How to process PDF (extract text from a large PDF file)
1) PDF format explain 
   - [[https://resources.infosecinstitute.com/topic/pdf-file-format-basic-structure/][PDF file format: Basic structure]]
2) Refs
   - [[https://elixirforum.com/t/lib-for-pdf-processing/2992][Lib for pdf processing]]
