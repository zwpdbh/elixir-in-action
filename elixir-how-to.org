* How to define functions 
  - Functions with same name but different arity is different function.
* How to define private function 
  - def is public, defp is private
  
* How to organize code 
  - A module is a collection of functions, like namespace. Functions must be defined inside a module.
  - A file can contain multiple module.
  - Rules
    - Module name starts with uppercase letter and is usually formated as CamelCase style.
    - Use ~.~ in module to represent herachichy. We could also define child module inside module.
    - Function name are like abc_def. 

* How to call functions from other module 
  - We could import other module into current module, to allow us to call functions without module prefix.
  - We could use change the module's name 
    #+begin_src text
      alias IO, as: MyIO
    #+end_src
  - For example, letâ€™s say you have a Geometry.Rectangle module. You can alias it in your client module and use a shorter name
    #+begin_src elixir
      defmodule MyModule do 
        alias Geometry.Rectangle, as: Rectange 
        
        def my_fun do
          Rectange.area(...)
        end
      end
    #+end_src
    
* How define constants in modules
  - Module attributes.
    - ~@~ constant exists only during the compilation of the module.
    
* How to compile the code 
  - In Emacs, ~M-x alchemist-iex-send-last-sexp~.
  - In terminal, ~iex geometry.ex~.
  
  The code will be compiled and resulting module is loaded into the runtime.
  
* How to do type specification
  #+begin_src elixir
    defmodule Circle do
      @pi 3.14
      
      @spec area(number) :: number 
      def area(r) do
        r * r * @pi
      end
    end
  #+end_src
  
* How to get the integer from div
  - The division operator ~/~ always return float.
  - To get integer use 
    - ~div~ to get the integer part.
    - ~rem~ to get the remainder
  
* How to define constant 
  - *Atom*, like ~:this_is_an_atom~

* How to use Tuples
  #+begin_src elixir
    person = {"bob", 25}
    
    age = elem(persion, 1) # => 25
    put_elem(person, 1, 100) # => {"bob", 100}
  #+end_src
  - Untyped structure, or record, group a *fixed* number of element together.
* How to use List 
  #+begin_src elixir
    iex(11)>prime_numbers = [2, 3, 5, 7]
    [2, 3, 5, 7]
    iex(12)> length(prime_numbers)
    length(prime_numbers)
    4
    iex(13)> Enum.at(prime_numbers, 1)
    Enum.at(prime_numbers, 1)
    3
    iex(14)> 100 in prime_numbers
    100 in prime_numbers
    false
    iex(15)> List.replace_at(prime_numbers, 0 , 11)
    List.replace_at(prime_numbers, 0 , 11)
    [11, 3, 5, 7]
    iex(16)> prime_numbers
    prime_numbers
    [2, 3, 5, 7]
    iex(17)> new_primes = List.replace_at(prime_numbers, 0 , 11)
    new_primes = List.replace_at(prime_numbers, 0 , 11)
    [11, 3, 5, 7]
    iex(18)> new_primes = List.insert_at(new_primes, 3, 13)
    new_primes = List.insert_at(new_primes, 3, 13)
    [11, 3, 5, 13, 7]
    iex(19)> new_primes
    new_primes
    [11, 3, 5, 13, 7]
    iex(20)> new_primes = List.insert_at(new_primes, -1, 103)
    new_primes = List.insert_at(new_primes, -1, 103)
    [11, 3, 5, 13, 7, 103]
    iex(21)> [1, 2, 3] ++ [4, 5]
    [1, 2, 3] ++ [4, 5]
    [1, 2, 3, 4, 5]
    iex(22)> hd([1, 2, 3, 4])
    hd([1, 2, 3, 4])
    1
    
    iex(23)> tl([1, 2, 3, 4])
    tl([1, 2, 3, 4])
    [2, 3, 4]
    
    iex(24)> a_list = [5, :value, true]
    a_list = [5, :value, true]
    [5, :value, true]
    iex(25)> new_list = [:new_element | a_list]
    new_list = [:new_element | a_list]
    [:new_element, 5, :value, true]
  #+end_src
  
* How to use Map 
  - As key/value store 
    #+begin_src elixir
      # Dynamically sized map 
      empty_map = %{}
      
      # map with value
      squares = %{1 => 1, 2 => 4, 3 => 9}
      # or 
      squares = Map.new([{1, 1}, {2, 4}, {3, 9}])
      
      # fetch value for a given key 
      squares[2] # where 1 is the key, => 4
      squares[7] # => nil
      # or 
      Map.get(squares, 2) # => 4
      Map.get(squares, 8, :not_found) #=> :not_found, use this to specify default value.
      Map.fetch(squares, 5) #=> :error  This will distinguishly produce  
      # or raise exception 
      Map.fetch!(squares, 5)
    #+end_src
  - power dynamically sized key/value structures, overlap Tuples' feature but let you to access fields by name
    #+begin_src elixir
      bob = %{:name => "Bob", :age => 25, :works_at => "Initech"}
      # if keys are atom, we could short as 
      bob = %{name: "Bob", age: 25, works_at: "Initech"}
       
      
      # fetch 
      bob[:works_at] # => Initech
      bod[:non_exist_key] #=> nil 
      # or use short syntax if key is atom 
      bob.age #=> 25
      # though it will get KeyError if the key is not exist
      
      
      next_bob = %{bob | age: 26}
      # => %{age: 26, name: "Bob", works_at: "Initech"}
      next_bob = %{bob | age: 26, works_at: "no_where"} # change multiple key/value
    #+end_src
    - Can only update keys exist in map!
    - *Use map to hold structured* data is very common.
      
* How to process binaries 
  - A binary is a chunk of byte
  - Create binary by enclosing the byte sequence
    #+begin_src elixir
      <<1, 2, 3>>
    #+end_src
    - Each number represent the value of the corresponding byte.
    - If the value is bigger than 255, it is truncated to the byte size
      #+begin_src elixir
        <<257>> #=> <<1>>
      #+end_src
  - Specify the size of each value and tell the compiler how many bits to use for that particular value 
    #+begin_src elixir
      <<234::16>> # => <<0, 234>>, used 2 bytes, the first has value 0, the second is 234 
      <<1234::32>> # => <<0, 0, 4, 210>>
    #+end_src
  - The size specifier is in *bits* and not needed to be a multiple of 8!!
    #+begin_src elixir
      <<1::4, 15::4>> # => <<31>>
    #+end_src
  - If the total size of all values is not a multiple of 8, it is called a bitstring -- a sequence of bits 
    #+begin_src elixir
      <<1::1, 0::1, 1::1>> # => <<5::size(3)>>
    #+end_src
  - Concatenate two binaries with ~<>~
    #+begin_src elixir
      <<1, 2>> <> <<3, 4>> # => <<1, 2, 3, 4>>
    #+end_src

* How to represent string 
  - String in elixir is either a binary or a list type.
  - String inter -- evaluate values in string template
    #+begin_src elixir
      "embedded expression: #{1 + 3}" #=>"embedded expression: 4"
    #+end_src
  - How to include quote inside string
    #+begin_src elixir
      ~s("embedded expression": #{1 + 3}) #=> "\"embedded expression\": 4"
      
      """ 
      embedded expression: "#{1 + 3}" 
      """
      # => "embedded expression: \"4\"\n"
    #+end_src
  - Aother way to represent string is use single-quote 
    #+begin_src elixir
      'ABC'
      [65, 66, 67] 
      # => they both produce 'ABC'
    #+end_src
    - The runtime doesn't distinguish between a list of integers and a character list.

* How to convert between binary string to character list 
  - binary string is represent using ~""~ while character list is represent as ~''~.
  - Use binary string as much as possbile
  - Convert 
    #+begin_src elixir
      String.to_charlist("ABC")       
    #+end_src

* How to define Lambda function and use it 
- basic lambda 
  #+begin_src elixir
    square = fn x ->
      x * x
    end

    iex(2)> square.(24)
    square.(24)
    576
  #+end_src
  - The dot operator is to make the code explicit such that you know an anonymous function is being called.
  - ~square(5)~ will be a named function defined somewhere in the module.
- *Capture* makes us to make full function qualifier as lambda 
  #+begin_src elixir
    Enum.each([1, 2, 3, 4], &IO.puts/1)

    iex(4)> Enum.each([1, 2, 3, 4], &IO.puts/1)
    1
    2
    3
    4
    :ok
  #+end_src
  
- The closure capture *doesn't* affect the previous defined lambda that references the same symbolic name
  #+begin_src elixir
    outside_var = 5
    lambda = fn -> IO.puts(outside_var) end
    outside_var = 6
    lambda.() #=> 5
  #+end_src
  
* How to use other types 
1) range
2) keyword list 
   - A list of pair, where the first one is atom.
   - Often used for small key-value structures.
   - Often used as the last optional argument when define a function.
3) MapSet, a set implementation
4) Time and date
   #+begin_src elixir
     date = ~D[2008-09-30]
     time = ~T[11:59:12]
     naive_datetime = ~N[2018-01-31 11:59:12.000007]
   #+end_src
5) *IO lists*
   - Special for incrementally building output that will be forwarded to an I/O service.
   - Appending to an IO list is O(1), very useful to incrementally build a stream of bytes 
     #+begin_src elixir
       iolist = []
       iolist = [iolist, "This"]
       iolist = [iolist, "is"]
       iolist = [iolist, "Amazing"]

       iex(20)> iolist = []
       iex(21)> [[], "This"]
       iex(22)> [[[], "This"], "is"]
       iex(23)> [[[[], "This"], "is"], "Amazing"]
       iex(24)> IO.puts(iolist)
       IO.puts(iolist)
       ThisisAmazing
       :ok
     #+end_src

* How to check the and load additional code paths 
- load additional code path from command-line when started erlang runtime 
  #+begin_src elixir
    $ iex -pa my/code/path -pa another/code/path # from command-line to load additional code path 
  #+end_src
- once start runtime, check current loaded path 
  #+begin_src elixir
    :code.get_path # check path 
  #+end_src  
  
* How to dynamically call a function  
#+begin_src elixir
  apply(IO, :puts, ["Dynamic function call."])
#+end_src

* How to run a single script
- Create ~.exs~ file 
  #+begin_src elixir :file script.exs
    defmodule MyModule do
      def run  do
        IO.puts("Called Mymodule.run")
      end
    end

    # Code outside of a module is executed immediately
    MyModule.run
  #+end_src

- On terminal 
  #+begin_src sh
    elixir script.exs
  #+end_src
  - With ~--no-halt~, it will make the BEAM instance keep running. Useful when your script start other concurrent tasks.

* How to get current time 
#+begin_src elixir
  iex(28)> {_, time} = :calendar.local_time()
  {{2022, 2, 11}, {13, 32, 10}}
  iex(29)> time 
  time 
  {13, 32, 10}
#+end_src

* How to handle exception error in guard
- If an error is raised from inside the guard, it won't be propagated. And the guard expression will return false. The corresponding clause won't match.

* How to match the content of variable
#+begin_src elixir
  iex(30)> expected_name = "bob"
  expected_name = "bob"
  "bob"
  iex(31)> {^expected_name, age} = {"bob", 25}
  {^expected_name, age} = {"bob", 25}
  {"bob", 25}
  iex(32)> age 
  age 
  25
#+end_src


* How to check the type of a variable
  - From REPL 
    #+begin_src elixir
      iex(10)> i x
      i x
      Term
        1
      Data type
        Integer
      Reference modules
        Integer
      Implemented protocols
        IEx.Info, Inspect, List.Chars, String.Chars
    #+end_src
  - From code 
    #+begin_src elixir
      defmodule Util do
          def typeof(a) do
              cond do
                  is_float(a)    -> "float"
                  is_number(a)   -> "number"
                  is_atom(a)     -> "atom"
                  is_boolean(a)  -> "boolean"
                  is_binary(a)   -> "binary"
                  is_function(a) -> "function"
                  is_list(a)     -> "list"
                  is_tuple(a)    -> "tuple"
                  true           -> "idunno"
              end    
          end
      end
      
      cases = [
          1.337, 
          1337, 
          :'1337', 
          true, 
          <<1, 3, 3, 7>>, 
          (fn(x) -> x end), 
          {1, 3, 3, 7}
      ]
      
      Enum.each cases, fn(case) -> 
          IO.puts (inspect case) <> " is a " <> (Util.typeof case)
      end
    #+end_src

* How to chain multiple pattern matching
  #+begin_src elixir
    defmodule ChainPattern do
      # define some helper function
      def extract_login(%{"login" => login}) do
        {:ok, login}
      end
      def extract_login(_) do
        {:error, "login missed"}
      end
    
      def extract_email(%{"email" => email}) do
        {:ok, email}
      end
      def extract_email(_) do
        {:error, "email missed"}
      end
    
      def extract_password(%{"password" => password}) do
        {:ok, password}
      end
      def extract_password(_) do
        {:error, "password missed"}
      end
    
    
      def extract_info(submitted) do
        with {:ok, login} <-extract_login(submitted),
          {:ok, email} <-extract_email(submitted),
          {:ok, password} <-extract_password(submitted) do
          {:ok, %{login: login, email: email, password: password}}
        end
      end
    end
    
    submitted = %{
      "login" => "alice",
      "email" => "some_email",
      "password" => "password",
      "other_field" => "some_value",
      "yet_another_not_wanted_field" => "..."
    }
    
    # iex(20)> ChainPattern.extract_info(submitted)
    # ChainPattern.extract_info(submitted)
    # {:ok, %{email: "some_email", login: "alice", password: "password"}}
  #+end_src
* How to build abstraction 
  - Princple
    - Module is used as the abstraction over the data type.
    - Modifier functions should return data of the same type. 
    - Query functions expect an instance of the data abstraction as the first argument and return another type of information.
* How to update hierachical data 
  - In general
    - We can't directly modify part of it that resides deep in its tree.
    - We have to walk down the tree to particular part that needs to be modified, and then transform it and all of its ancestors.
    - The result is a copy of the entire model.
  - Useful macros from Kernel:
    - ~put_in/2~
    - ~put_in/3~
    - ~get_in/2~
    - ~update_in/2~
    - ~get_and_update_in/2~
  - Those macros rely on the *Access* module. So, if we want our custom data to work with Access, we need to implement a couple of function required by *Access* contract. See: [[https://hexdocs.pm/elixir/Access.html][Access behaviour]]

* How to achieve polymorphism using protocols
  - What is a protocol 
    It is a module in which you declare functions without implementing them.
  - The protocol implementation doesn't need to be part of any module. It means: you can implement a protocol for a type even if you can't modify the type's source code.

* How to register a process
  - If you know there will always be only one instance of some type of server, you can give the process a local name and use that name to send messages to the process. The name is called local because it has meaning only in the currently running BEAM instance.
  - Using the registered server is much simpler becaue we don't need to pass server pid around through interface.
  - Example
    #+begin_src elixir
      Process.register(self(), :some_name)
      
      send(:some_name, :msg)
      receive do
        msg -> IO.puts("received #{msg}")
      end
    #+end_src
* How to handle unlimited process mailbox problem
  - If a message is not match, it will be stored in mailbox with unlimited number. If we don't process them, they will slow down the system and even crash the system when all memory is consumed.
  - For each server process, we should introduce a *match-all* receive clause that deals with unexpected kind of messages.

* How to implement a general server process
  - In general, there are 5 things to do 
    - spawn a seperate process
    - loop to infinite in that process  
    - receive message
    - send message back to the caller
    - maintain state


* How to debug
  - Check the representation of a struct 
    #+begin_src elixir
      Fraction.new(1,4)
      |> IO.inspect() 
      |> Fraction.add(Fraction.new(1,4))
      |> IO.inspect()
      |> Fraction.value()
      
      # %Fraction{a: 1, b: 4}
      # iex(70)> %Fraction{a: 1, b: 4}
      # %Fraction{a: 1, b: 4}
      # iex(71)> %Fraction{a: 8, b: 16}
      # iex(72)> %Fraction{a: 8, b: 16}
      # %Fraction{a: 8, b: 16}
      # iex(73)> 0.5
    #+end_src
* Some notes 
  - Always keep in mind that a Boolean is just an atom that has a value of true or false.
  - short-circuit operators: ~||~, ~&&~, ~!~.
    - ~||~ returns the first expression that isn't falsy.
      - Use for like 
        #+begin_src elixir
          read_cache || read_from_disk || read_from_database
        #+end_src
    
