* How to do authentication and authorization for Azure Storage
** Notes about access Azure 
- service principal
  - It's always recommended to use service principals with automated tools rather than allowing them to log in with a user identity.
  - See: [[https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal][Use the portal to create an Azure AD application and service principal that can access resources]]
- managed identities
- Azure AD authentication
** Authentication using Azure AD
- When authenticating using Azure AD, the Authorization header has the format
  #+begin_src text
    Authorization: bearer TOKEN
  #+end_src
  - Where ~TOKEN~ is the access token that the caller acquires by communicating with Azure AD service.
- General steps 
  1. Step one, the client 
     - Communicates with the Azure AD service.
     - Authenticates to the Azure AD.
     - Requests an access token issued specifically for the particular Azure Data Explorer endpoint the client intends to access.
  2. In the second step, the client issues requests to Azure Data Explorer, providing the access token acquired in the first step as a proof of identity to Azure Data Explorer.
     
** How to get access token from Azure AD service 
- The Azure AD service endpoint is https://login.microsoftonline.com/TENANT/
  - Where ~TENANT~ is the Azure AD tenant ID or name. 
    - If the services that are created under the Microsoft tenant, then use ~https://login.microsoftonline.com/microsoft.com/~.
    - If it is user authentication only, the request can be made to: ~https://login.microsoftonline.com/common/~.
  - Note: The Azure AD service endpoint changes when it runs in national clouds. To change the endpoint, set an environment variable ~AadAuthorityUri~ to the required URI.

** Calling Azure REST API using Service Principal
1. Create service principal 
   #+begin_src sh
     D:\code\elixir-programming>az ad sp create-for-rbac --name zwpdbh
     Found an existing application instance of "2470ca86-3843-4aa2-95b8-97d3a912ff69". We will patch it
     In a future release, this command will NOT create a 'Contributor' role assignment by default. If needed, use the --role argument to explicitly create a role assignment.
     Creating 'Contributor' role assignment under scope '/subscriptions/33922553-c28a-4d50-ac93-a5c682692168'
     The output includes credentials that you must protect. Be sure that you do not include these credentials in your code or check the credentials into your source control. For more information, see https://aka.ms/azadsp-cli
     'name' property in the output is deprecated and will be removed in the future. Use 'appId' instead.

     {
       "appId": "2470c...2ff69",
       "displayName": "zwpdbh",
       "name": "2470c...2ff69",
       "password": "N8qq...jQV6KSd.",
       "tenant": "72f988bf-86f1-41af-91ab-2d7cd011db47"
     }
   #+end_src
   - We could check the created service principal at 
     - Azure Active Directory
       - App registrations
         - Check tab: Owned application -- zwpdbh
           - Overview
         
** What is the certificates and secrets of a registered application 
- Where to check 
  - Azure Active Directory
    - App registrations
      - Click =+= new registration, follow instruction.
        - After creation, in the Manage tab, see "Certificates & secrets". There will be 3 sub tabs.
          - - What's the differences between "Client secrets" and "Certificates" =?=
            
- Check the "Client secrets"
  - We could click "+" to create client secret. 
    - Secret ID: 568855e2-5a16-44f5-9e5f-9e9d299c2afc
    - Value: 2y~8Q~blSah_XVUIGOzQ9IAzpyCZ1PicJCiBtbUc 
      - =Note=: Client secret values cannot be viewed, except for immediately after creation. Be sure to save the secret when created before leaving the page.
      - Right now, in my daily workflow process script. We use this value + application(client) id to request access token.
      
- Is this related with "Create service principal"
  - What is the password from the result of "az ad sp create-for-rbac --name zwpdbh"
    
** Understand my current workflow script parameters used for auth
Currently, I use a simple script to utilize RESTful API of DeploymentService(see ST.RestAPI). I set the following parameters:
- secret, which is the client secret' value 
- client_id, which is also the application id
- tenant "72f988bf-86f1-41af-91ab-2d7cd011db47", could be checked from Tenant properties --> Tenant ID.
  - It is used across multiple subscriptions.
- Unknown parameters
  - scope: ~https://microsoft.onmicrosoft.com/3b4ae08b-9919-4749-bb5b-7ed4ef15964d/.default~ (what is this 3b4ae08b-9919-4749-bb5b-7ed4ef15964d)
    - This url is from Application "ScenarioFramework" --> Overview --> Application ID URI
      - By clicking it, it is defined from "Expose an API".

** General steps to access Azure resources by role assignment using service principal
1. Create a service principal by registering an application
   1) Sign in Azure portal
   2) Select Azure Active Directory
   3) Select App registrations.
   4) Select New registration
      
   After we setup service principal we need to record down the following information 
   - Directory(tenant) ID: 72f988bf-86f1-41af-91ab-2d7cd011db47
   - Application (client) ID: 2470ca86-3843-4aa2-95b8-97d3a912ff69

2. Assign a role to the application 
   1) Select the level of scope you wish to assign the application. 
      - Here, level means subscription, resource group or specific resource. For example, we select the subscription: "XTest Test Cluster STG Tenant Load Generators 8".
   2) Select Access control (IAM)
   3) Check access tab --> Grant access to this resource --> Add role assignment
   4) Select the role by highlighting it
      - Here, I select "Contributor", click next
   5) Select members
      - Assign access to: User, group, or service principal.
      - Click "+ Select members"
      - Enter "zwpdbh" which is the application we registered in step 1.
   6) Review and assign

3. When programmatically signing in, pass the tenant ID and the application ID with your authentication request. You also need a certificate or an authentication key. We recommend using a certificate, but you can also create an application secret.
   - *Option 1*: Upload a certificate
     1) From powershell or VisualStudio terminal execute the following commands 
        #+begin_src powershell
          makecert -sky exchange -r -n "CN=zwpdbhREST" -pe -a sha1 -len 2048 -ss My "zwpdbhREST.cer"
        #+end_src
        - This will create a "zwpdbhREST.cer".
        - This also creates the certificate in the local machine under (type "Manage user certificate" from Windows Start)
          - Certificates - Current User
            - Personal
              - Certificates 
                - zwpdbhREST

     2) Export the certificate from certificat store as a ".cer" file (the same as "zwpdbhREST.cer")
        - Right click on the "zwpdbhREST"
          - All Tasks
            - Export
              - Select, "No, do not export the private key"
                - Select, "Base-64 encoded X.509 (.CER)"
                  - Type the certificate name to export. Here, I save it as "zwpdbhREST.cer".

     3) After we have exported the certificate. We need to upload it to the Azure subscription.
        - Login Azure and select the subscription we want to use, "XTest Test Cluster STG Tenant Load Generators 8 (33922553-c28a-4d50-ac93-a5c682692168)".
        - Settings
          - Management certificates
            - Click upload -- select our "zwpdbhREST.cer"

     What have doen:
     - Established a trust between Azure and the subscription agent via certificate authentication.
     - Subscription agent is the tool which programmatically carries our the tasks of a subscription owner.
     - Now, any subscription agent with the certificate can perform the subscription ownership tasks (using Azure Management API) thus aunenticating using the certificate.
       
     How to use this certificate? 
     - Identify this certificate from "LocalMachine", "CurrentUser", "My", X509 certificate with thumbprint.
     - The "thumbprint" could be checked by:
       - Double click the "zwpdbhREST" certificate
         - Check Details
           - Thumbprint
       - We could also check its thumbprint from the uploaded certificate in "Thumbprint" column from the "Management certificates" in Azure subscription.
   - *Option 2*: Create a new application secret
     In registered application: check the "Client secrets"
     - We could click "+" to create client secret. 
       - Secret ID: 5688...2afc
       - Value: 2y~8Q~blSah_XVUIGOzQ9IAzpyCZ1PicJCiBtbUc 
         - *Notice*: Client secret values cannot be viewed, except for immediately after creation. Be sure to save the secret when created before leaving the page.
         - Right now, in my daily workflow process script. We use this value + application(client) id to request access token.
           
           
** References 
- [[https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal][Use the portal to create an Azure AD application and service principal that can access resources]]


* How to contribute to a GitHub project 
- General steps 
  1) Create a personal fork of the project on Github.
  2) Clone the fork on your local machine. Your remote repo on Github is called ~origin~.
  3) Add the original repository as a remote called ~upstream~.
  4) If you created your fork a while ago be sure to pull upstream changes into your local repository.
  5) Create a new branch to work on! Branch from ~develop~ if it exists, else from ~master~.
  6) Implement/fix your feature, comment your code.
     - Follow the code style of the project, including indentation.
     - If the project has tests run them!
     - Write or adapt tests as needed.
     - Add or change the documentation as needed.
     - Squash your commits into a single commit with git's [[https://docs.github.com/en/get-started/using-git/about-git-rebase][interactive rebase]]. Create a new branch if necessary.
  7) Push your branch to your fork on Github, the remote ~origin~.
  8) From your fork open a pull request in the correct branch. Target the project's ~develop~ branch if there is one, else go for ~master~.
  9) Once the pull request is approved and merged you can pull the changes from ~upstream~ to your local repo and delete your extra branch(es).
     
  Notice: Your commit message should describe what the commit, when applied, does to the code â€“ not what you did to the code.

* How to use [[https://github.com/zabirauf/ex_microsoftbot#elixir-microsoft-bot-framework-client][Elixir Microsoft Bot Framework Client]]

* TODO How to build E2E test application like StorageAKS 
** Components (with implementation order)
1. Workflow module 
   - A pure group of functions. 
     - Each function receive a "params" map, and return a modifed "params" map.
   - Interal state: it has no interal state, this module only have pure functions to make functions in this module composible.
     
2. WorkflowExecution module
   - A module for managing a workflow's execution. It will implement ~GenServer~.
   - Interal state: 
     - A map contains a workflow execution's context.
     - It will be passed as the first argument to each workflow during execution.
   - Features of this module 
     1) Life cycle management of a workfow
        - when start, when finished
     2) Check current workflow's status (how???)
        - A workfow's log could reflect its status.
        - When a step of workflow is executed, it could send mesage to a pid to update its status(the params map).
          - DeploymentService use the concept of "Execution Pointers" to indicate each steps's status
          - We also need to record similar information, such that if something goes wrong, we could clean up created resources.
     3) Terminate a workflow 
        - A workflow could become terminated if it is finished.
        - Or, we could kill it.
          
   - So, the first argument of workflow should contains ???
     #+begin_src elixir
       %{}
     #+end_src
     
3. WorkflowManager module (how we work with multiple workflow executions)
   1) One workflow execution --- manage one workflow
      - A workflow execution maintains the state of a scenario test.
   2) A workflow manager --- manage multiple workflow executions (we run only one instance of this process)
      - A workflow manager manage multiple workflow execution
        - Do statistic collection
        - For some of execution, need to *sync* their result into group.
      - Given a workflow execution id, we create WorkflowExecution instance or fetch the existing one.
      - WorkflowManager module will implement ~GenServer~
        
   (see page 183 about how Todo.Cache is implemented)

   Concurrent behavior:
   1. Multiple clients (possibly a large number of http requests) issue requests to the single WorkflowManager process.
   2. Multiple clients communicate with multiple WorkflowExecution processes.
   3. Each WorkflowExecution process are independent to each other.
     
4. Database (how to persisting data)
   - Database module will use ~GenServer~.
   - The persisting data is all the workflow executions' state.
   - Database module, manage a pool of database workers, and forward database requests to them.
   - DatabaseWorker module, perform read/write operations on the database.

     
     
   

   





      





* References about Azure 
** About Authentication and Authorization
- About authentication with Azure Active Directory (Azure AD) for Azure Data Explorer access.
  - [[https://docs.microsoft.com/en-us/azure/data-explorer/kusto/management/access-control/how-to-authenticate-with-aad][How to authenticate with Azure Active Directory (Azure AD) for Azure Data Explorer access]]
  - [[https://docs.microsoft.com/en-us/azure/data-explorer/kusto/management/access-control/][Kusto Access Control Overview]]
- Use OAuth 2.0 client credentials 
  - [[https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow#get-a-token][Get a token -- My current simple workflow use this approach to send request to DeploymentService to manage workflow instance]]
- REST API for Azure 
  - [[https://docs.microsoft.com/en-us/rest/api/azure/][Azure REST API reference]]
  - [[https://mauridb.medium.com/calling-azure-rest-api-via-curl-eb10a06127][Calling Azure REST API via curl]]
  
* References about useful Elixir application 
** General 
- [[https://github.com/dashbitco/nimble_parsec][NimbleParsec]]
  - A simple and fast library for text-based parser combinators.
** About Azure Management 
*** Made by Dr Christian Geuer-Pollmann
- [[https://github.com/elixir-azure/ex_microsoft_azure_storage][ExMicrosoftAzureStorage]]
- [[https://github.com/zwpdbh/ex_microsoft_azure_utils][ExMicrosoftAzureManagementSamples]]
- [[https://github.com/zwpdbh/ex_microsoft_azure_management][ExMicrosoftAzureManagementSamples]]
- [[https://github.com/chgeuer/ex_microsoft_arm_evaluator][Microsoft.ARM.Evaluator]]
  Locally evaluating Azure ARM templates, see [[http://blog.geuer-pollmann.de/blog/2019/10/14/locally-evaluating-azure-arm-templates/][post about it]].
- [[https://github.com/chgeuer/elixir-livebook-azure-demo][chgeuer/elixir-livebook-azure-demo]]
  A small demo to show how to access Azure from Elixir.
