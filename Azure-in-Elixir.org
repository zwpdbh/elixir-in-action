* How to gain access to Azure storage
** Authentication using Azure AD
- When authenticating using Azure AD, the Authorization header has the format
  #+begin_src text
    Authorization: bearer TOKEN
  #+end_src
  - Where ~TOKEN~ is the access token that the caller acquires by communicating with Azure AD service.
- General steps 
  1. Step one, the client 
     - Communicates with the Azure AD service.
     - Authenticates to the Azure AD.
     - Requests an access token issued specifically for the particular Azure Data Explorer endpoint the client intends to access.
  2. In the second step, the client issues requests to Azure Data Explorer, providing the access token acquired in the first step as a proof of identity to Azure Data Explorer.
     
** How to get access token from Azure AD service 
- The Azure AD service endpoint is https://login.microsoftonline.com/TENANT/
  - Where ~TENANT~ is the Azure AD tenant ID or name. 
    - If the services that are created under the Microsoft tenant, then use ~https://login.microsoftonline.com/microsoft.com/~.
    - If it is user authentication only, the request can be made to: ~https://login.microsoftonline.com/common/~.
  - Note: The Azure AD service endpoint changes when it runs in national clouds. To change the endpoint, set an environment variable ~AadAuthorityUri~ to the required URI.


* How to contribute to a GitHub project 
- General steps 
  1) Create a personal fork of the project on Github.
  2) Clone the fork on your local machine. Your remote repo on Github is called ~origin~.
  3) Add the original repository as a remote called ~upstream~.
  4) If you created your fork a while ago be sure to pull upstream changes into your local repository.
  5) Create a new branch to work on! Branch from ~develop~ if it exists, else from ~master~.
  6) Implement/fix your feature, comment your code.
     - Follow the code style of the project, including indentation.
     - If the project has tests run them!
     - Write or adapt tests as needed.
     - Add or change the documentation as needed.
     - Squash your commits into a single commit with git's [[https://docs.github.com/en/get-started/using-git/about-git-rebase][interactive rebase]]. Create a new branch if necessary.
  7) Push your branch to your fork on Github, the remote ~origin~.
  8) From your fork open a pull request in the correct branch. Target the project's ~develop~ branch if there is one, else go for ~master~.
  9) Once the pull request is approved and merged you can pull the changes from ~upstream~ to your local repo and delete your extra branch(es).
     
  Notice: Your commit message should describe what the commit, when applied, does to the code â€“ not what you did to the code.


* How to use [[https://github.com/zabirauf/ex_microsoftbot#elixir-microsoft-bot-framework-client][Elixir Microsoft Bot Framework Client]]


* TODO How to build E2E test application like StorageAKS 
** Components (with implementation order)
1. Workflow module 
   - A pure group of functions. 
     - Each function receive a "params" map, and return a modifed "params" map.
   - Interal state: it has no interal state, this module only have pure functions to make functions in this module composible.
     
2. WorkflowExecution module
   - A module for managing a workflow's execution. It will implement ~GenServer~.
   - Interal state: 
     - A map contains a workflow execution's context.
     - It will be passed as the first argument to each workflow during execution.
   - Features of this module 
     1) Life cycle management of a workfow
        - when start, when finished
     2) Check current workflow's status (how???)
        - A workfow's log could reflect its status.
        - When a step of workflow is executed, it could send mesage to a pid to update its status(the params map).
          - DeploymentService use the concept of "Execution Pointers" to indicate each steps's status
          - We also need to record similar information, such that if something goes wrong, we could clean up created resources.
     3) Terminate a workflow 
        - A workflow could become terminated if it is finished.
        - Or, we could kill it.
          
   - So, the first argument of workflow should contains ???
     #+begin_src elixir
       %{}
     #+end_src
     
3. WorkflowManager module (how we work with multiple workflow executions)
   1) One workflow execution --- manage one workflow
      - A workflow execution maintains the state of a scenario test.
   2) A workflow manager --- manage multiple workflow executions (we run only one instance of this process)
      - A workflow manager manage multiple workflow execution
        - Do statistic collection
        - For some of execution, need to *sync* their result into group.
      - Given a workflow execution id, we create WorkflowExecution instance or fetch the existing one.
      - WorkflowManager module will implement ~GenServer~
        
   (see page 183 about how Todo.Cache is implemented)

   Concurrent behavior:
   1. Multiple clients (possibly a large number of http requests) issue requests to the single WorkflowManager process.
   2. Multiple clients communicate with multiple WorkflowExecution processes.
   3. Each WorkflowExecution process are independent to each other.
     
4. Database (how to persisting data)
   - Database module will use ~GenServer~.
   - The persisting data is all the workflow executions' state.
   - Database module, manage a pool of database workers, and forward database requests to them.
   - DatabaseWorker module, perform read/write operations on the database.

     
     
   

   





      






* References related with using Elixir for Azure 
** About Authentication and Authorization
- About authentication with Azure Active Directory (Azure AD) for Azure Data Explorer access.
  - [[https://docs.microsoft.com/en-us/azure/data-explorer/kusto/management/access-control/how-to-authenticate-with-aad][How to authenticate with Azure Active Directory (Azure AD) for Azure Data Explorer access]]
  - [[https://docs.microsoft.com/en-us/azure/data-explorer/kusto/management/access-control/][Kusto Access Control Overview]]
- Use OAuth 2.0 client credentials 
  - [[https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow#get-a-token][Get a token -- My current simple workflow use this approach to send request to DeploymentService to manage workflow instance]]
  
* References about useful Elixir application 
** General 
- [[https://github.com/dashbitco/nimble_parsec][NimbleParsec]]
  - A simple and fast library for text-based parser combinators.
** About Azure Management 
*** Made by Dr Christian Geuer-Pollmann
- [[https://github.com/elixir-azure/ex_microsoft_azure_storage][ExMicrosoftAzureStorage]]
- [[https://github.com/zwpdbh/ex_microsoft_azure_utils][ExMicrosoftAzureManagementSamples]]
- [[https://github.com/zwpdbh/ex_microsoft_azure_management][ExMicrosoftAzureManagementSamples]]
- [[https://github.com/chgeuer/ex_microsoft_arm_evaluator][Microsoft.ARM.Evaluator]]
  Locally evaluating Azure ARM templates, see [[http://blog.geuer-pollmann.de/blog/2019/10/14/locally-evaluating-azure-arm-templates/][post about it]].
- [[https://github.com/chgeuer/elixir-livebook-azure-demo][chgeuer/elixir-livebook-azure-demo]]
  A small demo to show how to access Azure from Elixir.
