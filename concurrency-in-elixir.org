* A simple ServerProcess (ch06 from Elixir in Action)
** The Generic server process 
1. A *server process* is a beam process that use recurive call (loop) to handle different messages.
   - Instead of directly handle different message in that server process, we provide the server process with a *callback module*.
     
2. The key to understand ServerProcess and callback module is:
   - *The state related with our custom module is maintained inside server process, not by callback module(client) itself*.
   - Therefore, the callback module is a group of =pure functions=.
   - For example in KeyValueStore, the state which is a map of key and value is updated not in the KeyValueStore module but in the ServerProcess module, in its recursive loop.
   - *callback functions* are always invoked in the server process., such as ~init/0~ and ~handle_call/2~.
   - *interface functions* are run in the client processes.

     
3. The generic server process does
   1) use endless recursive call to loop
   2) in loop, *maintain state*
   3) provide 2 type of interface functions to let callback module handle messages: one for sync, another for async.
      
4. The callback module receive and handle's the specific message.
   1) callback module call ~ServerProcess.start~ to register itself
   2) callback module handle messages by calling ~ServerProcess.call~ or ~ServerProcess.cast~. 
      - So, those messages are sent into server process in which the state could be updated.
      - The ~ServerProcess.call~ or ~ServerProcess.cast~ will send message to server_pid, so the messages are process in recursive ~loop~.
   3) ~ServerProcess.call/cast~ goes into server process's loop.
      In ServerProcess's recursive loop:
      - The message is processed by *callback module*'s ~:handle_call~ or ~:handle_cast~ which all need to return a new state. 
      - For ~:call~, we need to send message back before loop with new state.
        - Because the ~ServerProcess.call~ is blocking to receive this message.
      - After ~ServerProcess.call~ or ~ServerProcess.cast~ return. This goes back to in callback module 2).
        
* GenServer (ch06 from Elixir in Action)
** How to use GenServer in our module 
1) Define server callback functions: 
   - ~init/1~
   - ~handle_cast/2~
   - ~handle_call/3~
2) Define client API:
   - Use ~GenServer.start/2~ to start the process.
   - Use ~GenServer.cast/2~, ~GenServer.call/2~ to issue requests.
3) Some notes
   - The client is any process that invokes the client/interface functions.
   - The server is always the process identify or process name that we explicitly pass as argument to the client API.     
     
** What is the context of state in GenServer
- During loop in server process, it needs to maintain state. So the state needed to be carried in loop as argument.
- This also means, the callback module called inside the loop need to accept that state as argument.
- So, in GenServer, the state is carried as
  - the last argument for server all callbacks
  - the last element in the return tuple

** How to handle plain messages 
- We may need to handle messages that aren't specific to GenServer. 
  - For example, periodically send message by ~:timer.send_interval(5000, :cleanup)~.
- Use GenServer callback ~handle_info~ to handle it:
  #+begin_src elixir
    def handle_info(:cleanup, state) do
      IO.puts "performance cleanup"
      {:noreply, state}
    end
  #+end_src

** Understand the GenServer-powered processes. 
1) A client process starts the server by calling ~GenServer.start~ and providing the callback module. This creates the new server process which is powered by ~GenServer~.
2) When a message is received, ~GenServer~ invokes callback functions to handle it. Therefore, callback functions are always executed in server process.
3) The client process state is maintained in the GenServer loop but it is defined and manipulated by the callback functions:
   - It starts with ~init/1~ which defines the initial state that is then passed to subsequent ~handle_*~ callbacks.
   - Each of those callbacks receive the current state and must return its new version, which is used by the GenServer loop in place of the old one.
4) A [[https://elixir-lang.org/downloads/cheatsheets/gen-server.pdf][GenServer cheat sheet]]
  
* Building concurrency system (ch07 from Elixir in Action)
** General rules 
- Make server process do things in sequential way.
- Spawn multiple server processes to handle concurrency.
- In general, 
  - if we need to do synchronization between multiple processes, we let one dedicate process to handle these.
  - make concurrent process run independently.

** How to build a concurrency system (to-do lists example)
- Goal: a distributed HTTP server than can handle many end users who are simultaneously manipulating many to-do lists.
- Component
  - A pure functional Todo.List abstraction.
  - A to-do server process that can be used to manage one to-do list for a long time.
  - A cache for managing a map: we create Todo.Server instances or fetch the existing ones.
    - key is the to-do list name
    - value is the to-do server pid.
   
    This is how we work with multple to-do lists: run one instance of the existing to-do server for each to-do list.
    
* Fault-tolerance basics (ch08 from Elixir in Action)
** Rumtime error types
   BEAM distinguish 3 types of runtime errors ~:error~, ~:exit~, or ~:throw~.
1) For ~:error~
   - For example, invalid arithmetic expression, call a nonexistent function, patter-matching error.
   - You can *raise* your own error by using ~raise/1~ macro. If a function eplicitly raises an error, it should be appended with the ~!~ character to its name, for instance, ~File.open!~.
2) For ~:exit~
   - Use ~exit/1~ to exit the current process.
3) For ~:throw~
   - ~throw(:thrown_value)~
   - The purpose of throws is allow nonlocal returns. 
   
** Linking processes (*bidirectional*)
1) If two processes are linked, and one of the terminates, the other process receives a *exit signal*, a notification that a process has crashed.
   - A exit signal contains the pid of the crashed process and the *exit reasion*.

2) When a process terminates abnormally, the linked process is also take down.
3) How to create linked process 
   - If a link is created when you start a process, use ~spawn_link/1~.
   - Otherwise, use ~Process.link/1~ which connect the current process with another process.
4) Usually we don't want a linked process to crash. We could detect the process crash using *trapping exits*.
   #+begin_src elixir
     spawn(fn ->
       Process.flag(:trap_exit, true)
       spawn_link(fn -> raise("something went wrong") end)

       Process.sleep(1000)
       receive do
         msg -> IO.inspect(msg)
       end
     end)
   #+end_src
   - Format of the exit singal message is: ~{:EXIT, from_pid, exit_reason}~.
     + If a process is terminated due to a throw or an error, the exit reason is a tuple in the form ~{reason, where}~.
     + If a process is terminated due to an exit, the reason is a term provided to ~exit/1~.
** Monitors (*unidirectional*)
1) Make the current process monitor the target process. 
   #+begin_src elixir
     monitor_ref = Proccess.monitor(target_pid)
   #+end_src
   - If the monitored process dies, your process receives a message in the format:
     ~{:DOWN, monitor_ref, :process, from_pid, exit_reasion}~.
2) Stop the monitor 
   #+begin_src elixir
     Process.demonitor(monitor_ref)
   #+end_src

3) Exits are propagated through GenServer calls.
   When you issue a synchronous request via ~GenServer.call~, if a server process crashes, an exit signal will occur in your client process.
   
** Supervisors 
- A supervisor is a generic process whose only responsibility is to receive links and monitor notifications, and do something when a process crashes.
- Processes that aren't supervisors are called *workers*.
- When invoke ~Supervisor.start_link(child_specs, options)~, the following happens:
  1) The new process is started, powered by the ~Supervisor~ module.
  2) The supervisor process goes through the list of child specifications and starts each child, one by one.
  3) Each specification is resolved, if needed, by invoking ~child_spec/1~ from the corresponding module. 
     - The ~child_spec/1~ function is automatically defined when we use Agent, GenServer and Supervisor, etc.
  4) The supervisor starts the child process, according to the ~:start~ filed of the child specification.

- Start the supervisor as a module 
  #+begin_src elixir
    defmodule Todo.System do
      def start_link do
        Supervisor.start_link(
          [Todo.Cache],
          strategy: :one_for_one
        )
      end
    end

    # Todo.System.start_link()
  #+end_src
   
  Another callback module way to use supervisor 
  #+begin_src elixir
    defmodule Todo.System do
      use Supervisor

      def start_link do
        Supervisor.start_link(__MODULE__, nil)
      end

      def init(_) do
        Supervisor.init([Todo.Cache], strategy: :one_for_one)
      end
    end
  #+end_src

** Other notes 
- Every time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes.

- Learned functions 
  #+begin_src elixir
    # Get the pid from registered name
    cache_pid = Process.whereis(Todo.Cache)

    # Kill the process
    Process.exit(cache_pid, :kill)

    # Verify what the injected implementation of child_spec/1 returns:
    Todo.Cache.child_spec(nil)

    # check the number of running processes:
    :erlang.system_info(:process_count)
  #+end_src
  
** Current questions
- Explain ~start_link~, ~child_spec~, 
- Why use ETS?
  - Notice that before our changes KV.Registry.lookup/2 sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That鈥檚 the main idea behind the cache mechanism we are implementing.
- Differences between task, agents, generic servers, and supervisors.
  - Common
  - Different 
    
- About task 
  - Pass a two-element tuple as child specification, which in turn will invoke Task.start_link/1.
* TODO How to build a concurency system
** Components (with implementation order)
1. Workflow module 
   - A pure group of functions. 
     - Each function receive a "params" map, and return a modifed "params" map.
   - Interal state: it has no interal state, this module only have pure functions to make functions in this module composible.
     
2. WorkflowExecution module
   - A module for managing a workflow's execution. It will implement ~GenServer~.
   - Interal state: 
     - A map contains a workflow execution's context.
     - It will be passed as the first argument to each workflow during execution.
   - Features of this module 
     1) Life cycle management of a workfow
        - when start, when finished
     2) Check current workflow's status (how???)
        - A workfow's log could reflect its status.
        - When a step of workflow is executed, it could send mesage to a pid to update its status(the params map).
          - DeploymentService use the concept of "Execution Pointers" to indicate each steps's status
          - We also need to record similar information, such that if something goes wrong, we could clean up created resources.
     3) Terminate a workflow 
        - A workflow could become terminated if it is finished.
        - Or, we could kill it.
          
   - So, the first argument of workflow should contains ???
     #+begin_src elixir
       %{}
     #+end_src
     
3. WorkflowManager module (how we work with multiple workflow executions)
   1) One workflow execution --- manage one workflow
      - A workflow execution maintains the state of a scenario test.
   2) A workflow manager --- manage multiple workflow executions (we run only one instance of this process)
      - A workflow manager manage multiple workflow execution
        - Do statistic collection
        - For some of execution, need to *sync* their result into group.
      - Given a workflow execution id, we create WorkflowExecution instance or fetch the existing one.
      - WorkflowManager module will implement ~GenServer~
        
   (see page 183 about how Todo.Cache is implemented)

   Concurrent behavior:
   1. Multiple clients (possibly a large number of http requests) issue requests to the single WorkflowManager process.
   2. Multiple clients communicate with multiple WorkflowExecution processes.
   3. Each WorkflowExecution process are independent to each other.
     
4. Database (how to persisting data)
   - Database module will use ~GenServer~.
   - The persisting data is all the workflow executions' state.
   - Database module, manage a pool of database workers, and forward database requests to them.
   - DatabaseWorker module, perform read/write operations on the database.

     
     
   

   





      




* Nodes -- ch16 in Programming Elixir
- A common pattern: we have a module that is responsible both for spawning a process and for providing the external interface to that process.
- The general rue is to register your process names when your application starts.
- About input, output, pid and nodes (p227)
  - In elixir, you identify an open file or device by the pid of its I/O server.
  - The default device used by IO.puts is returned by the function ~:erlang.group_leader~.
  - So, by register the pid returned by ~group_leader~ under a global name, such as our node name. We can pass it to IO.puts. The output appears in the registered node terminal window.
