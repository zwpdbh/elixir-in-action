* A simple ServerProcess (ch06 from Elixir in Action)
** The Generic server process 
1. A *server process* is a beam process that use recurive call (loop) to handle different messages.
   - Instead of directly handle different message in that server process, we provide the server process with a *callback module*.
     
2. The key to understand ServerProcess and callback module is:
   - *The state related with our custom module is maintained inside server process, not by callback module(client) itself*.
   - Therefore, the callback module is a group of =pure functions=.
   - For example in KeyValueStore, the state which is a map of key and value is updated not in the KeyValueStore module but in the ServerProcess module, in its recursive loop.
   - *callback functions* are always invoked in the server process., such as ~init/0~ and ~handle_call/2~.
   - *interface functions* are run in the client processes.

     
3. The generic server process does
   1) use endless recursive call to loop
   2) in loop, *maintain state*
   3) provide 2 type of interface functions to let callback module handle messages: one for sync, another for async.
      
4. The callback module receive and handle's the specific message.
   1) callback module call ~ServerProcess.start~ to register itself
   2) callback module handle messages by calling ~ServerProcess.call~ or ~ServerProcess.cast~. 
      - So, those messages are sent into server process in which the state could be updated.
      - The ~ServerProcess.call~ or ~ServerProcess.cast~ will send message to server_pid, so the messages are process in recursive ~loop~.
   3) ~ServerProcess.call/cast~ goes into server process's loop.
      In ServerProcess's recursive loop:
      - The message is processed by *callback module*'s ~:handle_call~ or ~:handle_cast~ which all need to return a new state. 
      - For ~:call~, we need to send message back before loop with new state.
        - Because the ~ServerProcess.call~ is blocking to receive this message.
      - After ~ServerProcess.call~ or ~ServerProcess.cast~ return. This goes back to in callback module 2).
        
* GenServer (ch06 from Elixir in Action)
** How to use GenServer in our module 
1) Define server callback functions: 
   - ~init/1~
   - ~handle_cast/2~
   - ~handle_call/3~
2) Define client API:
   - Use ~GenServer.start/2~ to start the process.
   - Use ~GenServer.cast/2~, ~GenServer.call/2~ to issue requests.
3) Some notes
   - The client is any process that invokes the client/interface functions.
   - The server is always the process identify or process name that we explicitly pass as argument to the client API.     
     
** What is the context of state in GenServer
- During loop in server process, it needs to maintain state. So the state needed to be carried in loop as argument.
- This also means, the callback module called inside the loop need to accept that state as argument.
- So, in GenServer, the state is carried as
  - the last argument for server all callbacks
  - the last element in the return tuple

** How to handle plain messages 
- We may need to handle messages that aren't specific to GenServer. 
  - For example, periodically send message by ~:timer.send_interval(5000, :cleanup)~.
- Use GenServer callback ~handle_info~ to handle it:
  #+begin_src elixir
    def handle_info(:cleanup, state) do
      IO.puts "performance cleanup"
      {:noreply, state}
    end
  #+end_src

** Understand the GenServer-powered processes. 
1) A client process starts the server by calling ~GenServer.start~ and providing the callback module. This creates the new server process which is powered by ~GenServer~.
2) When a message is received, ~GenServer~ invokes callback functions to handle it. Therefore, callback functions are always executed in server process.
3) The client process state is maintained in the GenServer loop but it is defined and manipulated by the callback functions:
   - It starts with ~init/1~ which defines the initial state that is then passed to subsequent ~handle_*~ callbacks.
   - Each of those callbacks receive the current state and must return its new version, which is used by the GenServer loop in place of the old one.
4) A [[https://elixir-lang.org/downloads/cheatsheets/gen-server.pdf][GenServer cheat sheet]]
  
* Building concurrency system (ch07 from Elixir in Action)
** General rules 
- Make server process do things in sequential way.
- Spawn multiple server processes to handle concurrency.
- In general, 
  - if we need to do synchronization between multiple processes, we let one dedicate process to handle these.
  - make concurrent process run independently.

** How to build a concurrency system (to-do lists example)
- Goal: a distributed HTTP server than can handle many end users who are simultaneously manipulating many to-do lists.
- Component
  - A pure functional Todo.List abstraction.
  - A to-do server process that can be used to manage one to-do list for a long time.
  - A cache for managing a map: we create Todo.Server instances or fetch the existing ones.
    - key is the to-do list name
    - value is the to-do server pid.
   
    This is how we work with multple to-do lists: run one instance of the existing to-do server for each to-do list.
    
* Fault-tolerance basics (ch08 from Elixir in Action)
** Rumtime error types
   BEAM distinguish 3 types of runtime errors ~:error~, ~:exit~, or ~:throw~.
1) For ~:error~
   - For example, invalid arithmetic expression, call a nonexistent function, patter-matching error.
   - You can *raise* your own error by using ~raise/1~ macro. If a function eplicitly raises an error, it should be appended with the ~!~ character to its name, for instance, ~File.open!~.
2) For ~:exit~
   - Use ~exit/1~ to exit the current process.
3) For ~:throw~
   - ~throw(:thrown_value)~
   - The purpose of throws is allow nonlocal returns. 
   
** Linking processes (*bidirectional*)
1) If two processes are linked, and one of the terminates, the other process receives a *exit signal*, a notification that a process has crashed.
   - A exit signal contains the pid of the crashed process and the *exit reasion*.

2) When a process terminates abnormally, the linked process is also take down.
3) How to create linked process 
   - If a link is created when you start a process, use ~spawn_link/1~.
   - Otherwise, use ~Process.link/1~ which connect the current process with another process.
4) Usually we don't want a linked process to crash. We could detect the process crash using *trapping exits*.
   #+begin_src elixir
     spawn(fn ->
       Process.flag(:trap_exit, true)
       spawn_link(fn -> raise("something went wrong") end)

       Process.sleep(1000)
       receive do
         msg -> IO.inspect(msg)
       end
     end)
   #+end_src
   - Format of the exit singal message is: ~{:EXIT, from_pid, exit_reason}~.
     + If a process is terminated due to a throw or an error, the exit reason is a tuple in the form ~{reason, where}~.
     + If a process is terminated due to an exit, the reason is a term provided to ~exit/1~.
** Monitors (*unidirectional*)
1) Make the current process monitor the target process. 
   #+begin_src elixir
     monitor_ref = Proccess.monitor(target_pid)
   #+end_src
   - If the monitored process dies, your process receives a message in the format:
     ~{:DOWN, monitor_ref, :process, from_pid, exit_reasion}~.
2) Stop the monitor 
   #+begin_src elixir
     Process.demonitor(monitor_ref)
   #+end_src

3) Exits are propagated through GenServer calls.
   When you issue a synchronous request via ~GenServer.call~, if a server process crashes, an exit signal will occur in your client process.
   
** Supervisors 
- A supervisor is a generic process whose only responsibility is to receive links and monitor notifications, and do something when a process crashes.
- Processes that aren't supervisors are called *workers*.
- When invoke ~Supervisor.start_link(child_specs, options)~, the following happens:
  1) The new process is started, powered by the ~Supervisor~ module.
  2) The supervisor process goes through the list of child specifications and starts each child, one by one.
  3) Each specification is resolved, if needed, by invoking ~child_spec/1~ from the corresponding module. 
     - The ~child_spec/1~ function is automatically defined when we use Agent, GenServer and Supervisor, etc.
  4) The supervisor starts the child process, according to the ~:start~ filed of the child specification.

- Start the supervisor as a module 
  #+begin_src elixir
    defmodule Todo.System do
      def start_link do
        Supervisor.start_link(
          [Todo.Cache],
          strategy: :one_for_one
        )
      end
    end

    # Todo.System.start_link()
  #+end_src
   
  Another callback module way to use supervisor 
  #+begin_src elixir
    defmodule Todo.System do
      use Supervisor

      def start_link do
        Supervisor.start_link(__MODULE__, nil)
      end

      @impl true 
      def init(_) do
        Supervisor.init([Todo.Cache], strategy: :one_for_one)
      end
    end
  #+end_src
  - ~use Supervisor~ also defines a ~child_spec/1~ function which allows us to run this Todo.System as a child for another supervisor.
  - In this supervisor module 
    - Like GenServer, ~start_link~ --> Supervisor.init.
    - The first argument of Supervisor.init is a list of child_spec.
    - One child_spec can be obtained by ~Supervisor.child_spec~ function.

  =Note=: A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the Application.start/2 callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree.

** Other notes 
- Every time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes.

- Learned functions 
  #+begin_src elixir
    # Get the pid from registered name
    cache_pid = Process.whereis(Todo.Cache)

    # Kill the process
    Process.exit(cache_pid, :kill)

    # Verify what the injected implementation of child_spec/1 returns:
    Todo.Cache.child_spec(nil)

    # check the number of running processes:
    :erlang.system_info(:process_count)
  #+end_src
  
** Current questions
- Explain ~start_link~, ~child_spec~, 
- Why use ETS?
  - Notice that before our changes KV.Registry.lookup/2 sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That閳ユ獨 the main idea behind the cache mechanism we are implementing.
- Differences between task, agents, generic servers, and supervisors.
  - Common
  - Different 
    
- About task 
  - Pass a two-element tuple as child specification, which in turn will invoke Task.start_link/1.
* TODO How to build a concurency system
** Components (with implementation order)
1. Workflow module 
   - A pure group of functions. 
     - Each function receive a "params" map, and return a modifed "params" map.
   - Interal state: it has no interal state, this module only have pure functions to make functions in this module composible.
     
2. WorkflowExecution module
   - A module for managing a workflow's execution. It will implement ~GenServer~.
   - Interal state: 
     - A map contains a workflow execution's context.
     - It will be passed as the first argument to each workflow during execution.
   - Features of this module 
     1) Life cycle management of a workfow
        - when start, when finished
     2) Check current workflow's status (how???)
        - A workfow's log could reflect its status.
        - When a step of workflow is executed, it could send mesage to a pid to update its status(the params map).
          - DeploymentService use the concept of "Execution Pointers" to indicate each steps's status
          - We also need to record similar information, such that if something goes wrong, we could clean up created resources.
     3) Terminate a workflow 
        - A workflow could become terminated if it is finished.
        - Or, we could kill it.
          
   - So, the first argument of workflow should contains ???
     #+begin_src elixir
       %{}
     #+end_src
     
3. WorkflowManager module (how we work with multiple workflow executions)
   1) One workflow execution --- manage one workflow
      - A workflow execution maintains the state of a scenario test.
   2) A workflow manager --- manage multiple workflow executions (we run only one instance of this process)
      - A workflow manager manage multiple workflow execution
        - Do statistic collection
        - For some of execution, need to *sync* their result into group.
      - Given a workflow execution id, we create WorkflowExecution instance or fetch the existing one.
      - WorkflowManager module will implement ~GenServer~
        
   (see page 183 about how Todo.Cache is implemented)

   Concurrent behavior:
   1. Multiple clients (possibly a large number of http requests) issue requests to the single WorkflowManager process.
   2. Multiple clients communicate with multiple WorkflowExecution processes.
   3. Each WorkflowExecution process are independent to each other.
     
4. Database (how to persisting data)
   - Database module will use ~GenServer~.
   - The persisting data is all the workflow executions' state.
   - Database module, manage a pool of database workers, and forward database requests to them.
   - DatabaseWorker module, perform read/write operations on the database.

     
     
   

   





      




* Nodes -- ch16 in Programming Elixir
- A common pattern: we have a module that is responsible both for spawning a process and for providing the external interface to that process.
- The general rue is to register your process names when your application starts.
- About input, output, pid and nodes (p227)
  - In elixir, you identify an open file or device by the pid of its I/O server.
  - The default device used by IO.puts is returned by the function ~:erlang.group_leader~.
  - So, by register the pid returned by ~group_leader~ under a global name, such as our node name. We can pass it to IO.puts. The output appears in the registered node terminal window.

* OTP: Servers -- ch17 in Programming Elixir
1. ~start_link~ function asks GenServer to start a new process and link to us.
   - The second argument to ~start_link~ is the state which comes from the GenServer's callback function ~init~.
   - You can think of ~init~ as being like the constructor in an OOP language.
     - A constructor takes values and creates the object's initial state.
     - ~init~ takes some initial value and uses it to construct the state of the server.
2. Tracing a server's execution
   - In the third parameter to ~start_link~ is a set of options 
     #+begin_src elixir
       GenServer.start_link(Sequence.Server, state, [debug: [:trace]])
     #+end_src
   - We could also include ~:statistic~  to the debug list 
     #+begin_src elixir
       {:ok,pid} = GenServer.start_link(Sequence.Server, 100, [debug: [:statistics]])

       iex> :sys.statistics pid, :get
       {:ok,
        [
          start_time: {{2017, 12, 23}, {14, 6, 7}},
          current_time: {{2017, 12, 23}, {14, 6, 24}},
          reductions: 36,
          messages_in: 2,
          messages_out: 0
        ]}
     #+end_src
3. =sys= module is our interface to the world of system messages.
   - The list associated with the debug parameter you give to GenServer is simply the names of functions to call in the sys module.
   - We can turn things on and off after you have started a server. 
     #+begin_src elixir
       iex> :sys.trace pid, true
       :ok
       iex> GenServer.call(pid, :next_number) *DBG* <0.69.0> got call next_number from <0.25.0>
       ,*DBG* <0.69.0> sent 105 to <0.25.0>, new state 106
       105
       iex> :sys.trace pid, false
       :ok
       iex> GenServer.call(pid, :next_number)
       106
     #+end_src
     - ~pid~ is the result of ~GenServer.start_link~.
   - Other useful function
     - ~:sys.get_status pid~.
       - We could customize the formatting of the status message GenServer provides.
         #+begin_src elixir
           def format_status(_reason, [ _pdict, state ]) do
             [data: [{'State', "My current state is '#{inspect state}', and I'm happy"}]]
           end
         #+end_src

4. GenServer Callbacks and corresponding caller. (p238, ch17)
   - ~init(start_argument)~, <-- GenServer.start_link or GenServer.start (Note: The parameter is the second argument passed to GenServer.start_link or GenServer.start)
   - ~handle_call(request, from, state)~, <-- GenServer.call(pid, request)
   - ~handle_cast(request, state)~, <-- GenServer.cast(pid, request)
   - ~handle_info(info, state)~, message send by pass GenServer will be routed to this function.

   Responses are common between call and cast:
   #+begin_src elixir
     {:noreply, new_state [, :hibernate | timeout]}
     {:stop, reason, new_state}
   #+end_src
   
   Only ~handle_call~ can use:
   #+begin_src elixir
     {:reply, response, new_state [, :hibernate | timeout]}
     {:stop, reason, reply, new_state}
   #+end_src
   
5. Naming a process 
   - Local naming, use the ~name:~ option (unique for all OTP processes on our node.)
     #+begin_src elixir
       iex> { :ok, pid } = GenServer.start_link(Sequence.Server, 100, name: :seq)
       {:ok,#PID<0.58.0>}
       iex> GenServer.call(:seq, :next_number)
       100
     #+end_src




* About Supervisor Module 
1. ref: [[https://blog.appsignal.com/2021/08/23/using-supervisors-to-organize-your-elixir-application.html][Using Supervisors to Organize Your Elixir Application]]
2. How to add worker to a custom supervisor module at runtime 
   - Given 
     - Currently, our supervision tree looks like this 
       - OurNewApp.Supervisor 
         - OurNewApp.CounterSup 
           - {OurNewApp.Counter, 10000}
           - {OurNewApp.Counter, 20000}
     - WE want to add an exra OurNewApp.Counter under OurNewApp.CounterSup
   - General steps 
     #+begin_src elixir
       new_child_spec = Supervisor.child_spec({OurNewApp.Counter, 30000}, id: 30000)
       Supervisor.start_child(OurNewApp.CounterSup, new_child_spec)
     #+end_src
   - Notes:
     - Supervisor.start_child/2
     - Supervisor.delete_child/2
     - Supervisor.restart_child/2
3. How to add a new subtree with its own children (without creating a special module for the subtree supervisor)
   #+begin_src elixir
     children_specs = [10000, 20000, 30000] |> Enum.map(fn x ->
         Supervisor.child_spec({OurNewApp.Counter, x}, id: x)
       end)

     hand_crafted_sup_spec = %{
       id: :hand_crafted_sup,
       start: {Supervisor, :start_link, [children_specs, [strategy: :one_for_one]]},
       type: :supervisor,
       restart: :permanent,
       shutdown: 5000
     }

     Supervisor.start_child(OurNewApp.Supervisor, hand_crafted_sup_spec)
   #+end_src
   - Now, the supervision tree becomes 
     - OurNewApp.Supervisor (the root of our supervision tree)
       - OurNewApp.CounterSup 
         - {OurNewApp.Counter, 10000}
         - {OurNewApp.Counter, 20000}
       - :hand_crafted_sup 
         - {OurNewApp.Counter, 10000}
         - {OurNewApp.Counter, 20000}
         - {OurNewApp.Counter, 30000}
   - We could stop our application by 
     #+begin_src elixir
       Application.stop(:our_new_app)
     #+end_src
4. How to terminate a GenServer process with customization
   1) Modify the state it holds to hold a marker which will be indicate if process has been ordered to terminate.
   2) Through interface function, invoke GenServer.call and send message to indicate this process need to be terminated.
   3) During handle_call for that message, set the termination marker.
   4) User timer to send periodic info to self()
   5) During handle_info, check if the termination mark is present and if the desired condition is reached.
      - If so, {:stop, :normal, state}
      - Otherwise, update state (and timer)
        
   Note: during init/1, we also need to set flag 
   #+begin_src elixir
     Process.flag(:trap_exit, true)
   #+end_src
   
5. Beased on we could terminate a GenServer process, how to terminate a group of GenServer worker processes when we stop the application.
   - To do this, we must implement the callbacks ~prep_stop/1~.
   - For example 
     #+begin_src elixir
       @impl true
       def prep_stop(st) do
         stop_tasks =
           Supervisor.which_children(OurNewApp.CounterSup)
           |> Enum.map(fn {_, pid, _, _} ->
             Task.async(fn ->
               :ok = OurNewApp.Counter.stop_gracefully(pid)
             end)
           end)

         Task.await_many(stop_tasks)

         st
       end
     #+end_src
   
   
     
   
