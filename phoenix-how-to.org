* How to use Plug 
- ref: https://hexdocs.pm/phoenix/plug.html
  - For example, without using Plug, if we want to validate something in an controller, we will use nested blocks of code. 
    After using Plug, we could replace those nested block of code wit ha flattened series of plug transformations.
  - The ~halt(conn)~ the is key. It tells Plug that the next plug should not be invoked.
    
** How authentication is implemented in Rumbl application as plug
- In Rumbl, authentication is implemented with two plugs:
  - One is type of function plug, ~def authenticate_user(conn, _opts)~. It is used in ~user_controller~ module for action [:index, :show].
    #+begin_src elixir :file lib/rumbl_web/router.ex
      plug :authenticate_user when action in [:index, :show]
    #+end_src
  - Another is type of module plug, the ~RumblWeb.Auth~. It is used in pipeline ~browser~.
    #+begin_src elixir :file lib/rumbl_web/controllers/auth.ex
      pipeline :browser do
        plug :accepts, ["html"]
        ...
        # our own plug
        plug RumblWeb.Auth
      end
    #+end_src
- The module plug makes sure the conn's ~current_user~ property exist with value equals to ~user~ or ~nil~. This is for every connection.
- The function plug makes sure request to UserController's index and show path must contains ~user~.

** Controller are module plug to be used as [[https://hexdocs.pm/phoenix/controllers.html#action-fallback][action fallback]]
- Action fallback allows us to centralize error handling code in plugs which are called when a controller action fails to return a ~%Plug.Conn{}~ struct.

    
* Pipelines and Plugs 
- Pipelines are a series of plugs that can be attached to specific scopes.
- Routes are defined inside scopes and scopes may pipe through multiple pipelines.
- The router invokes a pipeline on a route defined *within* a scope. Routes outside of a scope have no pipelines.
** How to create pipelines
- Define custom pipelines anywhere in the router module.

* How to redirect a request 
- For example, we want to redirect user after he/she created account.
  #+begin_src elixir
    def create(conn, %{"user" => user_params}) do
      case Accounts.register_user(user_params) do
        # Do login if we insert the newly registered user in database.
        {:ok, user} ->
          conn
          |> RumblWeb.Auth.login(user)
          |> put_flash(:info, "#{user.name} created!")
          |> redirect(to: Routes.user_path(conn, :index))

        {:error, %Ecto.Changeset{} = changeset} ->
          render(conn, "new.html", changeset: changeset)
      end
    end
  #+end_src
  - *Notice*: Route helper function ~Routes.user_path~ is used to make sure the redirect path is correct.


* Controller 
** How to pass multiple values when render a template 
- For one value, we could use key: value pair as the third argument. Such as: ~render(conn, "show.html", messenger: messenger)~.
- For multiple values, we could use ~Plug.Conn.assign~:
  #+begin_src elixir
    def show(conn, %{"messenger" => messenger}) do
      conn
      |> assign(:messenger, messenger)
      |> assign(:receiver, "Dweezil")
      |> render("show.html")
    end
  #+end_src


* Ecto 
** How to create models (the data in DB)
- use phx.gen.schema
  #+begin_src sh
    mix phx.gen.schema User users name:string email:string \
        number_of_pets:integer
  #+end_src
  - This will generate two files, one is the ~user.ex~ model with schema, another is the ~xxx_create_user.exs~ which contains the migration for our DB.
  - After modifying them to perfectly suit our need, we run ~mix ecto.migrate~.
    
** About changeset 
- What is changeset?
  - A changeset defines some contains/validation for our data.
  - We use it by ~import Ecto.Changeset~ and it defines a lot of useful functions.
  - Use that module, we could validate our data which we want to insert into our db.
  - It will return a result with true or false, plus the changes (our validated/filtered data).
- How template and changeset are binded?
  - A changeset could be passed into template like this: ~render(conn, "new.html", changeset: changeset)~.
- What is the differences between validation and constraint
  - Validation executed before touching the db. And constraint rely on the database.
  - Therefore, validation happends before constraint.    

* Channels    
** About channels
- Channel is used for creating persistent connections.
- Components 
  1. Endpoint, in your Phoenix app's *Endpoint* module
     #+begin_src elixir :file lib/rumbl_web/endpoint.ex
       socket "/socket", RumblWeb.UserSocket,
         websocket: true,
         longpoll: false
     #+end_src
  2. Socket Handler
     1) On client side, we establish socket connection to the route
        #+begin_src elixir :file assets/js/socket.js
          import {Socket} from "phoenix"

          let socket = new Socket("/socket", {
            params: {token: window.userToken},
            logger: (kind, msg, data) => {console.log(`${kind}: ${msg}`, data)}
          })

          export default socket
        #+end_src
        - The point here is to create websocket connection to connect to ~/socket~ defined in RumblWeb.Endpoint module.

     2) On server side, inside RumblWeb.UserSocket module
        #+begin_src elixir :file rumbl_web/channels/user_socket.ex
          defmodule RumblWeb.UserSocket do
            use Phoenix.Socket

            channel "videos:*", RumblWeb.VideoChannel

            def connect(_params, socket, _connect_info) do
              {:ok, socket}
            end

            def id(_socket) do
              nil
            end
          end
        #+end_src
        - Whenever a client sends a message whose topic starts with "videos:", it will be routed to our ~VideoChannel~.
        - Implemented two callbacks.
         
  3. Define ~VideoChannel~ module to manage messages.
     #+begin_src elixir :file rumbl_web/channels/video_channel.ex
       defmodule RumblWeb.VideoChannel do
         use RumblWeb, :channel

         # "videos:" <> video_id will match all topics starting with "videos:"
         # and assign the rest of the topic to the video_id variable
         def join("videos:" <> video_id, _params, socket) do
           {:ok, assign(socket, :video_id, String.to_integer(video_id))}
         end
       end
     #+end_src
     - Let clients to join a given topic.

  4. Get the client and server talking
     1) Create socket and join a channel.
        #+begin_src js
        socket.connect()
        let vidChannel = socket.channel("videos:" + videoId)

        vidChannel.join()
          .receive("ok", resp => console.log("joined the video channel", resp))
          .receive("error", reason => {
            console.log("join failed", reason)
          })
        #+end_src

     2) Sending and Receiving events 
        - On client 
          #+begin_src js
            vidChannel.on("ping", ({count} => console.log("PING", count)))
          #+end_src

        - On server 
          #+begin_src elixir
            defmodule RumblWeb.VideoChannel do
              use RumblWeb, :channel

              # "videos:" <> video_id will match all topics starting with "videos:"
              # and assign the rest of the topic to the video_id variable
              def join("videos:" <> video_id, _params, socket) do
                # {:ok, assign(socket, :video_id, String.to_integer(video_id))}

                :timer.send_interval(5000, :ping)
                {:ok, socket}
              end

              def handle_info(:ping, socket) do
                count = socket.assigns[:count] || 1

                push(socket, "ping", %{count: count})
                {:noreply, assign(socket, :count, count + 1)}
              end
            end
          #+end_src
          - Our server send to "videos:" channel a message for every 5 second.
          - ~handle_info~ callback is invoked whenever an elixir message reaches the channel.
           
           

- In general,
  - On server
    - Define a socket module and mount it as a socket endpoint. Inside this socket module:
      - Implement ~id/1~ and ~connect/3~ methods.
      - Define channel routes with its channel module.
    - Define a channel module 
      - Define how client join a given topic by implementing ~join/3~.
      - Handle incoming events by using 
        - ~handle_in~
        - ~handle_out~
        - ~handle_info~
  - On client
    - Import socket, connect to an socket endpoint defined by server.
    - Create channel using ~socket.channel~. After that join the channel(~someChannel.join~) and receive message (~someChannel.receive~).
    - Handle channel's event like ~someChannel.on("someEvent", callback)~.
       
       

     





* Other what/how

